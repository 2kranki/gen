// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

// io[[.TD.Data.TitledName]] contains all the functions
// and data to interact with the SQL Database.

[[- $dot := .]]
[[- $d  := .TD.Data]]
[[- $dn := .TD.Data.TitledName]]
[[- $plg := $d.Plugin.Plugin]]
[[- $typ := $plg.Name]]

// Generated: [[Time]] for [[$typ]] Database

package io[[$dn]]

import (
	"testing"
    [[ if ne $typ "sqlite" -]]
	"time"
	[[- end ]]
	"../util"
)


var io      *IO_[[$dn]]


[[ if eq $typ "mariadb" -]]
//----------------------------------------------------------------------------
//                              Docker Run - mariadb
//----------------------------------------------------------------------------

// DockerRun executes the dbs/[[$typ]]/run.sh to create a fresh SQL Server.
func DockerRun(t *testing.T) {
    var err         error
    var exec        *util.ExecCmd
    var output      string

	t.Logf("DockerRun()...\n")

	exec = util.NewExecCmd("../../dbs/[[$typ]]/run.sh")
	if exec == nil {
        t.Fatalf("Error: Failed to create util.ExecCmd instance!\n\n")
	}

    output, err = exec.RunWithOutput()
    if err != nil {
        t.Fatalf("Error: %s\n\n", err)
    }
    t.Logf("%s\n", output)
    time.Sleep(5000 * time.Millisecond)


	t.Logf("DockerRun() - End\n\n\n")
}
[[ else if eq $typ "mssql" -]]
//----------------------------------------------------------------------------
//                              Docker Run - mssql
//----------------------------------------------------------------------------

// DockerRun executes the dbs/[[$typ]]/run.sh to create a fresh SQL Server.
func DockerRun(t *testing.T) {
    var err         error
    var exec        *util.ExecCmd
    var output      string

	t.Logf("DockerRun()...\n")

	exec = util.NewExecCmd("../../dbs/[[$typ]]/run.sh")
	if exec == nil {
        t.Fatalf("Error: Failed to create util.ExecCmd instance!\n\n")
	}

    output, err = exec.RunWithOutput()
    if err != nil {
        t.Fatalf("Error: %s\n\n", err)
    }
    t.Logf("%s\n", output)
    time.Sleep(5000 * time.Millisecond)

	t.Logf("DockerRun() - End\n\n\n")
}
[[ else if eq $typ "mysql" -]]
//----------------------------------------------------------------------------
//                              Docker Run - mysql
//----------------------------------------------------------------------------

// DockerRun executes the dbs/[[$typ]]/run.sh to create a fresh SQL Server.
func DockerRun(t *testing.T) {
    var err         error
    var exec        *util.ExecCmd
    var output      string

	t.Logf("DockerRun()...\n")

	exec = util.NewExecCmd("../../dbs/[[$typ]]/run.sh")
	if exec == nil {
        t.Fatalf("Error: Failed to create util.ExecCmd instance!\n\n")
	}

    output, err = exec.RunWithOutput()
    if err != nil {
        t.Fatalf("Error: %s\n\n", err)
    }
    t.Logf("%s\n", output)
    time.Sleep(5000 * time.Millisecond)

	t.Logf("DockerRun() - End\n\n\n")
}
[[ else if eq $typ "postgres" -]]
//----------------------------------------------------------------------------
//                              Docker Run - postgres
//----------------------------------------------------------------------------

// DockerRun executes the dbs/[[$typ]]/run.sh to create a fresh SQL Server.
func DockerRun(t *testing.T) {
    var err         error
    var exec        *util.ExecCmd
    var output      string

	t.Logf("DockerRun()...\n")

	exec = util.NewExecCmd("../../dbs/[[$typ]]/run.sh")
	if exec == nil {
        t.Fatalf("Error: Failed to create util.ExecCmd instance!\n\n")
	}

    output, err = exec.RunWithOutput()
    if err != nil {
        t.Fatalf("Error: %s\n\n", err)
    }
    t.Logf("%s\n", output)
    time.Sleep(5000 * time.Millisecond)

	t.Logf("DockerRun() - End\n\n\n")
}
[[ else if eq $typ "sqlite" -]]
//----------------------------------------------------------------------------
//                              Docker Run - sqlite
//----------------------------------------------------------------------------

// DockerRun executes the dbs/[[$typ]]/run.sh to create a fresh SQL Server.
func DockerRun(t *testing.T) {
    var err         error
    var exec        *util.ExecCmd

	t.Logf("DockerRun()...\n")

	exec = util.NewExecCmd("../../dbs/[[$typ]]/run.sh")
	if exec == nil {
        t.Fatalf("Error: Failed to create util.ExecCmd instance!\n\n")
	}

    //err = exec.Run()      // Not needed for sqlite!
    if err != nil {
        t.Fatalf("Error: %s\n\n", err)
    }

	t.Logf("DockerRun() - End\n\n\n")
}
[[ end ]]

//============================================================================
//                              Tests
//============================================================================

//----------------------------------------------------------------------------
//                              Connect
//----------------------------------------------------------------------------

func TestConnect(t *testing.T) {
    var err         error

	t.Logf("TestConnect()...\n")
	DockerRun(t)

	io = New()
	io.DefaultParms()
    err = io.Connect("")
    if err == nil {
	    err = io.Disconnect()
        if err != nil {
            t.Fatalf("Error: %s\n\n", err)
        }
        io = nil
    } else {
            t.Fatalf("Error: %s\n\n", err)
    }

	t.Logf("TestConnect() - End of Test\n\n\n")
}

//----------------------------------------------------------------------------
//                              Disconnect
//----------------------------------------------------------------------------

func TestDisconnect(t *testing.T) {
    var err         error

	t.Logf("TestDisconnect()...\n")
	io = New()
	io.DefaultParms()

	// Disconnect before a connection has been made.
    err = io.Disconnect()
    if err == nil {
        t.Fatal("Error: Never Connected!\n\n\n")
    }

    if io.IsConnected() {
        t.Fatal("Error: Never Connected!\n\n\n")
    }

    // Now connect then disconnect.
    err = io.Connect("")
    if err != nil {
        t.Fatal("Error: Cannot connect: ", err)
    }

    if !io.IsConnected() {
        t.Fatal("Error: Never Connected!\n\n\n")
    }

    err = io.Disconnect()
    if err != nil {
        t.Fatal("Error: Cannot disconnect: ", err)
    }

	t.Logf("TestDisconnect() - End of Test\n\n\n")
}

[[ if eq $typ "mssql" -]]
//----------------------------------------------------------------------------
//                              IsDatabaseDefined
//----------------------------------------------------------------------------

func TestIsDatabaseDefined(t *testing.T) {
    var err         error

	t.Logf("TestIsDatabaseDefined()...\n")
	DockerRun(t)

	io = New()
	io.DefaultParms()
    err = io.Connect("")
    if err != nil {
        t.Fatalf("Error: %s\n\n", err)
    }

    if !io.IsDatabaseDefined("[[$dn]]") {
        err = io.DatabaseCreate("[[$dn]]")
        if err != nil {
            t.Fatalf("\tError - Database Create failed: %s\n", err.Error())
        }
    }

    err = io.Disconnect()
    if err != nil {
        t.Fatalf("Error: %s\n\n", err)
    }
    io = nil

	t.Logf("TestIsDatabaseDefined() - End of Test\n\n\n")
}
[[ end ]]

//----------------------------------------------------------------------------
//                              QueryRow
//----------------------------------------------------------------------------

func TestQueryRow(t *testing.T) {
    var err         error

	t.Logf("TestQueryRow()...\n")
	//DockerRun(t)

	io = New()
	io.DefaultParms()
    err = io.Connect("")
    if err != nil {
        t.Fatalf("Error: %s\n\n", err)
    }

    [[ if ne $typ "sqlite" -]]
    if !io.IsDatabaseDefined("[[$dn]]") {
        err = io.DatabaseCreate("[[$dn]]")
        if err != nil {
            t.Errorf("\tError - Database Create failed: %s\n", err.Error())
        }
    }
    [[- end ]]

    err = io.Disconnect()
    if err != nil {
        t.Fatalf("Error: %s\n\n", err)
    }
    io = nil

	t.Logf("TestQueryRow() - End of Test\n\n\n")
}
