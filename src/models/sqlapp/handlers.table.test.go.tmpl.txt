// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

// io[[.TD.Data.TitledName]] contains all the functions
// and data to interact with the SQL Database.

// Generated: [[Time]]
[[- $dot := .]]
[[- $d  := .TD.Data]]
[[- $dn := .TD.Data.TitledName]]
[[- $t := .Table]]
[[- $tn := .Table.TitledName]]

package hndlr[[$dn]][[$tn]]

import (
	"../[[$dn]][[$tn]]"
    "fmt"
    "io/ioutil"
    "log"
    "net/http"
    "net/http/httptest"
    //"net/url"
    "sort"
    "strings"
	"testing"
)

//============================================================================
//                              Fake DB
//============================================================================

type FakeDB struct {
    rcds        map[string][[$dn]][[$tn]].[[$tn]]
    errorOut    bool
}

func (db *FakeDB) SetErrorOut(f bool) {
    db.errorOut = f
}

//----------------------------------------------------------------------------
//                             Row Delete
//----------------------------------------------------------------------------

// RowDelete deletes the row with keys from the provided record, rcd.
func (db *FakeDB) RowDelete(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBRowDelete()\n")
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        key := rcd.KeysToValue()
        log.Printf("\tkey: (%d)%s\n", len(key), key)
        if *rcd, ok = db.rcds[key]; !ok {
            err = fmt.Errorf("Error - Record Not Found!\n")
        }
        delete(db.rcds, key)
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBRowDelete(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row Find
//----------------------------------------------------------------------------

// RowFind searches the Database for a matching row for the keys found in
// the given record and returns the output in that same record.
func (db *FakeDB) RowFind(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBRowFind(%+v)\n", rcd)
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        key := rcd.KeysToValue()
        log.Printf("\tkey: (%d)%s\n", len(key), key)
        if *rcd, ok = db.rcds[key]; !ok {
            err = fmt.Errorf("Error - Record Not Found!\n")
        }
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBRowFind(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row First
//----------------------------------------------------------------------------

// RowFirst returns the first row in the table, [[$tn]].
// If there are no rows in the table, then a blank/null record is returned
// without error.
func (db *FakeDB) RowFirst(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var keys        []string

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBRowFirst()\n")
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        for key := range db.rcds {
            keys = append(keys, key)
        }
        sort.Strings(keys)
        if len(keys) > 0 {
            *rcd = db.rcds[keys[0]]
        } else {
            rcd.Empty()
        }
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBRowFirst(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row Insert
//----------------------------------------------------------------------------

func (db *FakeDB) RowInsert(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBRowInsert(%+v)\n", rcd)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        key := rcd.KeysToValue()
        log.Printf("\tkey: (%d)%s\n", len(key), key)
        db.rcds[key] = *rcd
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBRowInsert(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row Last
//----------------------------------------------------------------------------

func (db *FakeDB) RowLast(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var keys        []string

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBRowLast(%+v)\n", rcd)
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        for key := range db.rcds {
            keys = append(keys, key)
        }
        sort.Strings(keys)
        if len(keys) > 0 {
            *rcd = db.rcds[keys[len(keys)-1]]
        }
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBRowLast(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row Next
//----------------------------------------------------------------------------

// RowNext returns the next row from the row given. If row after the current
// one does not exist, then the first row is returned.
func (db *FakeDB) RowNext(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var keys        []string
    var i           int

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBRowNext(%+v)\n", rcd)
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        var wrkRcd  [[$dn]][[$tn]].[[$tn]]
        for key := range db.rcds {
            keys = append(keys, key)
        }
        sort.Strings(keys)
        if len(keys) > 0 {
            for i=0; i<len(keys); i++ {
                wrkRcd = db.rcds[ keys[i] ]
                j := rcd.CompareKeys(&wrkRcd)
                if j > 0 {
                    break
                }
            }
            if i < len(db.rcds) {
                *rcd = db.rcds[ keys[i] ]
            } else {
                err = fmt.Errorf("Error - Record Not Found!\n")
            }
        } else {
            err = fmt.Errorf("Error - Empty Database!\n")
        }
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBRowNext(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row Page
//----------------------------------------------------------------------------

// RowPage returns a page of rows where a page size is the 'limit' parameter and
// 'offset' is the offset into the result set ordered by the main index. Both
// 'limit' and 'offset' are relative to 1. We return an address to the array
// rows (structs) so that we don't have the overhead of copying them everwhere.
func (db *FakeDB) RowPage(offset int, limit int) ([][[$dn]][[$tn]].[[$tn]], error) {
    var err         error

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBRowPage(%d,%d)\n",offset,limit)
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        err = fmt.Errorf("Error - Not Implemented!\n")
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBRowPage(%s)\n", ErrorString(err))
    [[end]]
    return nil, err
}

//----------------------------------------------------------------------------
//                             Row Prev
//----------------------------------------------------------------------------

func (db *FakeDB) RowPrev(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBRowPrev(%+v)\n", rcd)
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        err = fmt.Errorf("Error - Not Implemented!\n")
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBRowPrev(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Row Update
//----------------------------------------------------------------------------

func (db *FakeDB) RowUpdate(d *[[$dn]][[$tn]].[[$tn]]) error {
    var err     error

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBRowUpdate(%+v)\n", d)
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        err = fmt.Errorf("Error - Not Implemented!\n")
    }


    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBRowUpdate(%s)\n", ErrorString(err))
    [[end]]
	return err
}


//----------------------------------------------------------------------------
//                             Table Count
//----------------------------------------------------------------------------

func (db FakeDB) TableCount( ) (int, error) {
    var err         error
    var count       int

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBTableCount()\n")
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        count = len(db.rcds)
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBTableCount(%s) %d\n", ErrorString(err), count)
    [[end]]
    return count, err
}

//----------------------------------------------------------------------------
//                             Table Create
//----------------------------------------------------------------------------

// TableCreate creates the table in the given database deleting the current
// table if present.
func (db FakeDB) TableCreate() error {
    var err     error

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBTableCreate()\n")
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        err = fmt.Errorf("Error - Not Implemented!\n")
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBTableCreate(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Table Delete
//----------------------------------------------------------------------------

// TableDelete deletes the table in the given database if present.
func (db FakeDB) TableDelete() error {
    var err     error

    [[if GenDebugging]]
        log.Printf("[[$tn]].DBTableDelete()\n")
    [[end]]

    if db.errorOut {
        err = fmt.Errorf("Error - Error Out!\n")
    } else {
        err = fmt.Errorf("Error - Not Implemented!\n")
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].DBTableDelete(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//============================================================================
//                              Tests
//============================================================================

//----------------------------------------------------------------------------
//                          FakeDB First/Next
//----------------------------------------------------------------------------

func Test[[$tn]]DBFirstNext(t *testing.T) {
    var err         error
    var fdb         *FakeDB
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var rcd2        [[$dn]][[$tn]].[[$tn]]

    t.Logf("Test[[$tn]].DBFirstNext()...\n")
    fdb = &FakeDB{ rcds:map[string][[$dn]][[$tn]].[[$tn]]{}, errorOut:false, }
    if fdb == nil {
        t.Fatalf("Error: Unable to allocate FakeDB\n")
    }
    t.Logf("\tAdding test records...\n")
    for i:=0; i<20; i++ {
        rcd.TestData(i)
        err = fdb.RowInsert(&rcd)
        if err == nil {
            t.Fatalf("Error: Unable to insert test record %d in FakeDB!\n", i)
        }
    }

    // Now check first.
    err = fdb.RowFirst(&rcd2)
    rcd.TestData(0)
    if 0 != rcd.CompareKeys(&rcd2) {
        t.Errorf("Error - First did not work, need A, got %q\n", rcd2)
    }

    t.Logf("Test[[$tn]].DBFirstNext() - End of Test\n\n\n")
}

//----------------------------------------------------------------------------
//                             List Index
//----------------------------------------------------------------------------

func Test[[$tn]]ListIndex(t *testing.T) {
    var err         error
    var fdb         *FakeDB
    var h           *Handlers

    t.Logf("Test[[$tn]].HndlrIndex()...\n")
    fdb = &FakeDB{}
    if fdb == nil {
        t.Fatalf("Error: Unable to allocate FakeDB\n")
    }
    h = &Handlers{db:fdb, rowsPerPage:2}
    if h == nil {
        t.Fatalf("Error: Unable to allocate Handlers\n")
    }

    //TODO: err = db.Ping()
    if err != nil {
        t.Fatalf("Error: Cannot connect: %s\n", err.Error())
    }

    t.Logf("Test[[$tn]].HndlrIndex() - End of Test\n\n\n")
}

//----------------------------------------------------------------------------
//                             List Show
//----------------------------------------------------------------------------

func TestListShow(t *testing.T) {
    var fdb         *FakeDB
    var h           *Handlers
    //TODO: var rcd         [[$dn]][[$tn]].[[$tn]]
    //TODO: var w           *httptest.ResponseRecorder

    t.Logf("TestListShow()...\n")
    fdb = &FakeDB{}
    if fdb == nil {
        t.Fatalf("Error: Unable to allocate FakeDB\n")
    }
    h = &Handlers{db:fdb, rowsPerPage:2}
    if h == nil {
        t.Fatalf("Error: Unable to allocate Handlers\n")
    }
    //TODO: w = httptest.NewRecorder()

    // First try a blank record.
    //TODO: h.ListShow(w, &rcd, "")
    //TODO: resp := w.Result()
    // fmt.Println(resp.StatusCode)
    // fmt.Println(resp.Header.Get("Content-Type"))
    //TODO: body, _ := ioutil.ReadAll(resp.Body)
    //TODO: t.Logf("Output:\n%s\n\n\n", string(body))

    t.Logf("TestListShow() - End of Test\n\n\n")
}

//----------------------------------------------------------------------------
//                             Row Delete
//----------------------------------------------------------------------------

func TestRowDelete(t *testing.T) {
    var err         error
    var fdb         *FakeDB
    var h           *Handlers
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var mux         *http.ServeMux
    var w           *httptest.ResponseRecorder
    var resp        *http.Response
    expectedBody    := ""

    t.Logf("TestRowDelete()...\n")
    fdb = &FakeDB{ rcds:map[string][[$dn]][[$tn]].[[$tn]]{}, errorOut:false, }
    if fdb == nil {
        t.Fatalf("Error: Unable to allocate FakeDB\n")
    }
    t.Logf("\tAdding test records...\n")
    for i:=0; i<20; i++ {
        rcd.TestData(i)
        err = fdb.RowInsert(&rcd)
        if fdb == nil {
            t.Fatalf("Error: Unable to insert test record %d in FakeDB!\n", i)
        }
    }
    h = &Handlers{db:fdb, rowsPerPage:2}
    if h == nil {
        t.Fatalf("Error: Unable to allocate Handlers\n")
    }

    // Now set up the Server mux for the test.
    mux = http.NewServeMux()
    if mux == nil {
        t.Fatalf("Error: Unable to allocate HTTP mux\n")
    }
    h.SetupHandlers(mux)

    // Delete a record.
    rcd.TestData(2)             // "C"
    keys := rcd.KeysToValue()
    t.Logf("\tSetting up to delete (%d)\"%s\" row...\n", len(keys), keys)
    urlStr := fmt.Sprintf("/[[$tn]]/delete?%s", keys)
    r := httptest.NewRequest("GET", urlStr, nil)
    t.Logf("\tKeys: %q\n", r.URL.Query()["key"])
    w = httptest.NewRecorder()
    mux.ServeHTTP(w, r)             // Perform the test through the mux.

    // Now get the Response and check it.
    resp = w.Result()
    if resp == nil {
        t.Fatalf("Error: Unable to get response!\n")
    }
    if resp.StatusCode != http.StatusOK {
        t.Errorf("Unexpected status code %d", resp.StatusCode)
    }
    if resp.StatusCode != 200 {
        t.Fatalf("Received non-200 response: %d\n", resp.StatusCode)
    }
    t.Logf("\t actualHeader: %q\n", resp.Header)
    actualBody, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        t.Fatal(err)
    }
    t.Logf("\t actualBody: %s\n", string(actualBody))
    if expectedBody != string(actualBody) {
        t.Errorf("Expected the message '%s'\n", expectedBody)
    }

    rcd.TestData(2)             // "B"
    err = fdb.RowFind(&rcd)
    if err == nil {
        t.Errorf("Expected Not Found error from RowFind, got ok\n")
    }

    t.Logf("TestRowDelete() - End of Test\n\n\n")
}

//----------------------------------------------------------------------------
//                             Row Insert
//----------------------------------------------------------------------------

func Test[[$tn]]RowInsert(t *testing.T) {
    var err         error
    var fdb         *FakeDB
    var h           *Handlers
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var mux         *http.ServeMux
    var w           *httptest.ResponseRecorder
    var resp        *http.Response
    expectedBody    := ""

    t.Logf("Test[[$tn]]RowInsert()...\n")
    fdb = &FakeDB{ rcds:map[string][[$dn]][[$tn]].[[$tn]]{}, errorOut:false, }
    if fdb == nil {
        t.Fatalf("Error: Unable to allocate FakeDB\n")
    }
    t.Logf("\tAdding test records...\n")
    for i:=0; i<20; i++ {
        rcd.TestData(i)
        err = fdb.RowInsert(&rcd)
        if fdb == nil {
            t.Fatalf("Error: Unable to insert test record %d in FakeDB!\n", i)
        }
    }
    h = &Handlers{db:fdb, rowsPerPage:2}
    if h == nil {
        t.Fatalf("Error: Unable to allocate Handlers\n")
    }

    // Now set up the Server mux for the test.
    mux = http.NewServeMux()
    if mux == nil {
        t.Fatalf("Error: Unable to allocate HTTP mux\n")
    }
    h.SetupHandlers(mux)

    // Insert a record.
    rcd.TestData(25)        // "Z"
    keys := rcd.KeysToValue()
    data := rcd.FieldsToValue()
    urlStr := fmt.Sprintf("/[[$tn]]/insert?%s", keys)
    t.Logf("\tSetting up to insert (%d)\"%s\" row...\n", len(keys), keys)
    r := httptest.NewRequest("POST", urlStr, strings.NewReader(data))
    t.Logf("\tKeys: %q\n", r.URL.Query()["key"])
    w = httptest.NewRecorder()
    mux.ServeHTTP(w, r)             // Perform the test through the mux.

    // Now get the Response and check it.
    resp = w.Result()
    if resp == nil {
        t.Fatalf("Error: Unable to get response!\n")
    }
    if resp.StatusCode != http.StatusOK {
        t.Errorf("Unexpected status code %d", resp.StatusCode)
    }
    if resp.StatusCode != 200 {
        t.Fatalf("Received non-200 response: %d\n", resp.StatusCode)
    }
    t.Logf("\t actualHeader: %q\n", resp.Header)
    actualBody, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        t.Fatal(err)
    }
    t.Logf("\t actualBody: %s\n", string(actualBody))
    if expectedBody != string(actualBody) {
        t.Errorf("Expected the message '%s'\n", expectedBody)
    }

    rcd.TestData(25)             // "Z"
    err = fdb.RowFind(&rcd)
    if err == nil {
        t.Errorf("Expected Not Found error from RowFind, got ok\n")
    }

    t.Logf("Test[[$tn]]RowInsert() - End of Test\n\n\n")
}

//----------------------------------------------------------------------------
//                             Row First
//----------------------------------------------------------------------------

func Test[[$tn]]RowFirst(t *testing.T) {
    var err         error
    var fdb         *FakeDB
    var h           *Handlers
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var mux         *http.ServeMux
    var w           *httptest.ResponseRecorder
    var resp        *http.Response
    expectedBody    := ""

    t.Logf("Test[[$tn]].RowFirst()...\n")
    fdb = &FakeDB{ rcds:map[string][[$dn]][[$tn]].[[$tn]]{}, errorOut:false, }
    if fdb == nil {
        t.Fatalf("Error: Unable to allocate FakeDB\n")
    }
    t.Logf("\tAdding test records...\n")
    for i:=0; i<20; i++ {
        rcd.TestData(i)
        err = fdb.RowInsert(&rcd)
        if fdb == nil {
            t.Fatalf("Error: Unable to insert test record %d in FakeDB!\n", i)
        }
    }
    h = &Handlers{db:fdb, rowsPerPage:2}
    if h == nil {
        t.Fatalf("Error: Unable to allocate Handlers\n")
    }

    // Now set up the Server mux for the test.
    mux = http.NewServeMux()
    if mux == nil {
        t.Fatalf("Error: Unable to allocate HTTP mux\n")
    }
    h.SetupHandlers(mux)

    // Delete a record.
    rcd.TestData(2)             // "C"
    keys := rcd.KeysToValue()
    t.Logf("\tSetting up to delete (%d)\"%s\" row...\n", len(keys), keys)
    urlStr := fmt.Sprintf("/[[$tn]]/delete?%s", keys)
    r := httptest.NewRequest("GET", urlStr, nil)
    t.Logf("\tKeys: %q\n", r.URL.Query()["key"])
    w = httptest.NewRecorder()
    mux.ServeHTTP(w, r)             // Perform the test through the mux.

    // Now get the Response and check it.
    resp = w.Result()
    if resp == nil {
        t.Fatalf("Error: Unable to get response!\n")
    }
    if resp.StatusCode != http.StatusOK {
        t.Errorf("Unexpected status code %d", resp.StatusCode)
    }
    if resp.StatusCode != 200 {
        t.Fatalf("Received non-200 response: %d\n", resp.StatusCode)
    }
    t.Logf("\t actualHeader: %q\n", resp.Header)
    actualBody, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        t.Fatal(err)
    }
    t.Logf("\t actualBody: %s\n", string(actualBody))
    if expectedBody != string(actualBody) {
        t.Errorf("Expected the message '%s'\n", expectedBody)
    }

    t.Logf("Test[[$tn]].RowFirst() - End of Test\n\n\n")
}

//----------------------------------------------------------------------------
//                             Row Prev
//----------------------------------------------------------------------------

func Test[[$tn]]RowLastPrev(t *testing.T) {
    var err         error
    var fdb         *FakeDB
    var h           *Handlers

    t.Logf("Test[[$tn]].RowPrev()...\n")
    fdb = &FakeDB{}
    if fdb == nil {
        t.Fatalf("Error: Unable to allocate FakeDB\n")
    }
    h = &Handlers{db:fdb, rowsPerPage:2}
    if h == nil {
        t.Fatalf("Error: Unable to allocate Handlers\n")
    }

    //TODO: err = db.Ping()
    if err != nil {
        t.Fatalf("Error: Cannot connect: %s\n", err.Error())
    }

    t.Logf("Test[[$tn]].RowPrev() - End of Test\n\n\n")
}

//----------------------------------------------------------------------------
//                             Row Display
//----------------------------------------------------------------------------

func Test[[$tn]]RowDisplay(t *testing.T) {
    var fdb         *FakeDB
    var h           *Handlers
    //TODO: var w           *httptest.ResponseRecorder

    t.Logf("Test[[$tn]].RowDisplay()...\n")
    fdb = &FakeDB{}
    if fdb == nil {
        t.Fatalf("Error: Unable to allocate FakeDB\n")
    }
    h = &Handlers{db:fdb, rowsPerPage:2}
    if h == nil {
        t.Fatalf("Error: Unable to allocate Handlers\n")
    }
    //TODO: w = httptest.NewRecorder()

    //TODO: req := httptest.NewRequest("GET", "http://localhost:5000/[[$tn]]", nil)
    //TODO: h.RowShow(w, req)
    //TODO: resp := w.Result()
    // fmt.Println(resp.StatusCode)
    // fmt.Println(resp.Header.Get("Content-Type"))
    //TODO: body, _ := ioutil.ReadAll(resp.Body)
    //TODO: t.Logf("Output:\n%s\n\n\n", string(body))

    t.Logf("Test[[$tn]]RowShow() - End of Test\n\n\n")
}

//----------------------------------------------------------------------------
//                             Row Update
//----------------------------------------------------------------------------

func Test[[$tn]]RowUpdate(t *testing.T) {
    var err         error
    var fdb         *FakeDB
    var h           *Handlers

    t.Logf("Test[[$tn]].RowUpdate()...\n")
    fdb = &FakeDB{}
    if fdb == nil {
        t.Fatalf("Error: Unable to allocate FakeDB\n")
    }
    h = &Handlers{db:fdb, rowsPerPage:2}
    if h == nil {
        t.Fatalf("Error: Unable to allocate Handlers\n")
    }

    //TODO: err = db.Ping()
    if err != nil {
        t.Fatalf("Error: Cannot connect: %s\n", err)
    }

    t.Logf("Test[[$tn]].RowUpdate() - End of Test\n\n\n")
}

