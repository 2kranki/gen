// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

// SQL Application main program

// Generated: [[Time]]
[[- $n := .TD.Data.TitledName]]

package main

import (
    "fmt"
    "log"
	"net/http"
	"os"
    "os/signal"
	"./hndlr[[$n]]"
	"./io[[$n]]"
)

func HndlrFavIcon(w http.ResponseWriter, r *http.Request) {

    [[if GenDebugging]]
        fmt.Printf("HndlrFavIcon(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
	    http.NotFound(w, r)
	}
    http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)

    [[if GenDebugging]]
        fmt.Printf("...end HndlrFavIcon(Error:405)\n")
    [[end]]
}

func HndlrHome(w http.ResponseWriter, r *http.Request) {

    [[if GenDebugging]]
        fmt.Printf("HndlrHome(%s)\n", r.Method)
    [[end]]

    if r.URL.Path != "/" {
        [[if GenDebugging]]
            fmt.Printf("HndlrHome(Error 404) Not '/' URL\n")
        [[end]]
        http.NotFound(w, r)
        return
    }

    [[if GenDebugging]]
        fmt.Printf("HndlrHome(%s) Serving File: ./html/[[$n]].menu.htm\n")
    [[end]]
    http.ServeFile(w, r, "./html/[[$n]].menu.html")

    [[if GenDebugging]]
        fmt.Printf("...end HndlrHome()\n")
    [[end]]
}

[[if GenDebugging]]
    func HndlrDebug(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebug(%s)\n", r.Method)
        http.ServeFile(w, r, "./html/form.html")
        fmt.Printf("...end HndlrDebug()\n")
    }

    func HndlrDebugAdd(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugAdd(%s)\n", r.Method)
        if r.Method != "POST" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Good Addition!")
    }

    func HndlrDebugDelete(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugDelete(%s)\n", r.Method)
        if r.Method != "POST" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Good Deletion!")
    }

    func HndlrDebugNext(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugNext(%s)\n", r.Method)
        if r.Method != "GET" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Going to Next!")
    }

    func HndlrDebugPrev(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugPrev(%s)\n", r.Method)
        if r.Method != "GET" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Going to Prev!")
    }

    func HndlrDebugReset(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugReset(%s)\n", r.Method)

        fmt.Fprintf(w, "Doing a Reset!")
    }

    func HndlrDebugUpdate(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugUpdate(%s)\n", r.Method)
        if r.Method != "POST" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Good Update!")
    }
[[end]]

func exec() {

    // Connect the databases.
    [[if GenDebugging]]
        log.Printf("\tConnecting to the Database...\n")
    [[end]]
    io[[$n]].SetPort(db_port)
    io[[$n]].SetPW(db_pw)
    io[[$n]].SetPort(db_port)
    io[[$n]].SetServer(db_srvr)
    io[[$n]].SetUser(db_user)
    err := io[[$n]].Connect()
    if err != nil {
        log.Fatalf("ERROR - Failed to Connect Databases\n\n\n")
    }
    chnl := make(chan os.Signal, 1)
    signal.Notify(chnl, os.Interrupt, os.Kill)
    go func(){
        <-chnl
        if io[[$n]].IsConnected() {
            io[[$n]].Disconnect()
        }
        os.Exit(1)
    }()

    // Set up templates.
    [[if GenDebugging]]
        log.Printf("\tSetting up the Templates...\n")
    [[end]]
    hndlr[[$n]].SetupTmpls()

    // Set up default URL handlers
    [[if GenDebugging]]
        log.Printf("\tSetting up the Mux Handlers...\n")
    [[end]]
    mux := http.NewServeMux()
	mux.HandleFunc("/", HndlrHome)
	mux.HandleFunc("/favicon.ico", HndlrFavIcon)

	// Set up Debug URL handlers to practice on simple form
    [[if GenDebugging]]
        mux.HandleFunc("/debug", HndlrDebug)
        mux.HandleFunc("/debugAdd", HndlrDebugAdd)
        mux.HandleFunc("/debugDelete", HndlrDebugDelete)
        mux.HandleFunc("/debugNext", HndlrDebugNext)
        mux.HandleFunc("/debugPrev", HndlrDebugPrev)
        mux.HandleFunc("/debugReset", HndlrDebugReset)
        mux.HandleFunc("/debugUpdate", HndlrDebugUpdate)
    [[end]]

	[[range $t := .TD.Data.Tables -]]
	    // [[$t.Name]] URL handlers for table maintenance
	    mux.HandleFunc("/[[$t.Name]]/list/first",         hndlr[[$n]].[[$t.TitledName]]HndlrListFirst)
	    mux.HandleFunc("/[[$t.Name]]/list/last",          hndlr[[$n]].[[$t.TitledName]]HndlrListLast)
	    mux.HandleFunc("/[[$t.Name]]/list/next",          hndlr[[$n]].[[$t.TitledName]]HndlrListNext)
	    mux.HandleFunc("/[[$t.Name]]/list/prev",          hndlr[[$n]].[[$t.TitledName]]HndlrListPrev)
	    mux.HandleFunc("/[[$t.Name]]/table/create",       hndlr[[$n]].[[$t.TitledName]]HndlrTableCreate)
	    mux.HandleFunc("/[[$t.Name]]/table/loadcsv",      hndlr[[$n]].[[$t.TitledName]]HndlrTableLoadCSV)
	    mux.HandleFunc("/[[$t.Name]]/table/load",         hndlr[[$n]].[[$t.TitledName]]HndlrTableLoad)
	    mux.HandleFunc("/[[$t.Name]]/delete",             hndlr[[$n]].[[$t.TitledName]]HndlrDelete)
	    mux.HandleFunc("/[[$t.Name]]/empty",              hndlr[[$n]].[[$t.TitledName]]HndlrEmpty)
	    mux.HandleFunc("/[[$t.Name]]/find",               hndlr[[$n]].[[$t.TitledName]]HndlrFind)
	    mux.HandleFunc("/[[$t.Name]]/first",              hndlr[[$n]].[[$t.TitledName]]HndlrFirst)
	    mux.HandleFunc("/[[$t.Name]]/form",               hndlr[[$n]].[[$t.TitledName]]HndlrForm)
	    mux.HandleFunc("/[[$t.Name]]/insert",             hndlr[[$n]].[[$t.TitledName]]HndlrInsert)
	    mux.HandleFunc("/[[$t.Name]]/last",               hndlr[[$n]].[[$t.TitledName]]HndlrLast)
	    mux.HandleFunc("/[[$t.Name]]/next",               hndlr[[$n]].[[$t.TitledName]]HndlrNext)
	    mux.HandleFunc("/[[$t.Name]]/prev",               hndlr[[$n]].[[$t.TitledName]]HndlrPrev)
	    mux.HandleFunc("/[[$t.Name]]/show",               hndlr[[$n]].[[$t.TitledName]]HndlrShow)
	    mux.HandleFunc("/[[$t.Name]]/update",             hndlr[[$n]].[[$t.TitledName]]HndlrUpdate)
	    mux.HandleFunc("/[[$t.Name]]",                    hndlr[[$n]].[[$t.TitledName]]HndlrIndex)
	[[ end -]]

	// Start the HTTP Server.
	srvrStr := fmt.Sprintf("%s:%s", http_srvr, http_port)
	log.Fatal(http.ListenAndServe(srvrStr, mux))

}

