// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

// SQL Application main program

// Generated: [[Time]]
[[- $dot := .]]
[[- $d  := .TD.Data]]
[[- $dn := .TD.Data.TitledName]]
[[- $plg := $d.Plugin.Plugin]]
[[- $typ := $plg.Name]]

package main

import (
    "fmt"
    "log"
	"net/http"
	"os"
    "os/signal"
	"./hndlr[[$dn]]"
	"./io[[$dn]]"
	[[range $t := $d.Tables -]]
        [[- $tn := $t.TitledName]]
        "./hndlr[[$dn]][[$tn]]"
	    "./io[[$dn]][[$tn]]"
	[[end]]
)

const (
    RowsPerPage = 15
)

// HndlrFavIcon is the default Favorite Icon Handler.  It defaults to
// returning a 405 status to indicate that no Icon is available.
func HndlrFavIcon(w http.ResponseWriter, r *http.Request) {

    [[if GenDebugging]]
        fmt.Printf("HndlrFavIcon(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
	    http.NotFound(w, r)
	}
    http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)

    [[if GenDebugging]]
        fmt.Printf("...end HndlrFavIcon(Error:405)\n")
    [[end]]
}

// HndlrHome responds to a URL with no sub-elements.  It defaults to
// providing the default Menu to the browser/caller.
func HndlrHome(w http.ResponseWriter, r *http.Request) {

    [[if GenDebugging]]
        fmt.Printf("HndlrHome(%s)\n", r.Method)
    [[end]]

    if r.URL.Path != "/" {
        [[if GenDebugging]]
            fmt.Printf("...end HndlrHome(Error 404) Not '/' URL\n")
        [[end]]
        http.NotFound(w, r)
        return
    }

    [[if GenDebugging]]
        fmt.Printf("\tHndlrHome Serving File: ./html/[[$dn]].menu.html\n")
    [[end]]
    http.ServeFile(w, r, baseDir+"/html/[[$dn]].menu.html")

    [[if GenDebugging]]
        fmt.Printf("...end HndlrHome()\n")
    [[end]]
}

[[if GenDebugging]]
    func HndlrDebug(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebug(%s)\n", r.Method)
        http.ServeFile(w, r, baseDir+"/html/form.html")
        fmt.Printf("...end HndlrDebug()\n")
    }

    func HndlrDebugAdd(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugAdd(%s)\n", r.Method)
        if r.Method != "POST" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Good Addition!")
    }

    func HndlrDebugDelete(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugDelete(%s)\n", r.Method)
        if r.Method != "POST" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Good Deletion!")
    }

    func HndlrDebugNext(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugNext(%s)\n", r.Method)
        if r.Method != "GET" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Going to Next!")
    }

    func HndlrDebugPrev(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugPrev(%s)\n", r.Method)
        if r.Method != "GET" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Going to Prev!")
    }

    func HndlrDebugReset(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugReset(%s)\n", r.Method)

        fmt.Fprintf(w, "Doing a Reset!")
    }

    func HndlrDebugUpdate(w http.ResponseWriter, r *http.Request) {
        fmt.Printf("HndlrDebugUpdate(%s)\n", r.Method)
        if r.Method != "POST" {
            http.NotFound(w, r)
        }
        fmt.Fprintf(w, "Good Update!")
    }
[[end]]

[[ if GenMuxWrapper -]]
// To understand the following, review packages net/http and net/url and review:
// https://stackoverflow.com/questions/25456390/how-to-log-http-server-errors-in-golang

// MuxResponseWriterWrap provides a wrapper around the Response
// Writer so that we can intercept data being written out if
// needed.
type MuxResponseWriterWrap struct {
	http.ResponseWriter
	status int
}

func (r *MuxResponseWriterWrap) Write(p []byte) (int, error) {
	return r.ResponseWriter.Write(p)
}

func (r *MuxResponseWriterWrap) WriteHeader(status int) {
	r.status = status
	r.ResponseWriter.WriteHeader(status)
}

// MuxHandlerWrapper will intercept each mux request and give
// us access both, before and after, the request is handled.
func MuxHandlerWrapper(f http.Handler) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		record := &MuxResponseWriterWrap{
			ResponseWriter: w,
		}

        // Intercept before the request is handled.
		log.Println("mux input: (", r.Method, ") ", r.URL.String())

		f.ServeHTTP(record, r)

        // Intercept after the request is handled.
		log.Println("Bad Request ", record.status)

		if record.status == http.StatusBadRequest {
			log.Println("Bad Request ", r)
		}
	}
}

[[- end ]]

func exec() {

    // Connect the databases.
    [[if GenDebugging]]
        log.Printf("\tConnecting to the Database...\n")
    [[end]]
    io[[$dn]] := io[[$dn]].New()
    //io[[$dn]].SetName(db_name)
    io[[$dn]].SetPort(db_port)
    io[[$dn]].SetPW(db_pw)
    io[[$dn]].SetPort(db_port)
    io[[$dn]].SetServer(db_srvr)
    io[[$dn]].SetUser(db_user)
    err := io[[$dn]].DatabaseCreate(db_name)
    if err != nil {
        log.Fatalf("ERROR - Failed to Connect Database\n\n\n")
    }
    chnl := make(chan os.Signal, 1)
    signal.Notify(chnl, os.Interrupt, os.Kill)
    go func(){
        <-chnl
        if io[[$dn]].IsConnected() {
            io[[$dn]].Disconnect()
        }
        os.Exit(1)
    }()

    // Set up the Table I/O.
	[[range $t := $d.Tables -]]
        [[- $tn := $t.TitledName]]
	    io[[$dn]][[$tn]] := io[[$dn]][[$tn]].[[$tn]]New(io[[$dn]])
        if io[[$dn]][[$tn]] == nil {
            log.Fatalf("ERROR - Failed to Connect to Table, [[$dn]][[$tn]]\n\n\n")
        }
	[[end]]

    // Set up templates.
    [[if GenDebugging]]
        log.Printf("\tSetting up the Templates...\n")
    [[end]]
    hndlr[[$dn]].SetTmplsDir(baseDir + "/tmpl")
    hndlr[[$dn]].SetupTmpls()
	[[range $t := $d.Tables -]]
        [[- $tn := $t.TitledName]]
	    hndlr[[$dn]][[$tn]].Tmpls = hndlr[[$dn]].Tmpls
        if hndlr[[$dn]][[$tn]].Tmpls == nil {
            log.Fatalf("ERROR - Failed to load templates from hndlr[[$dn]]\n\n\n")
        }
	[[end]]

    // Set up default URL handlers
    [[if GenDebugging]]
        log.Printf("\tSetting up the Mux Handlers...\n")
    [[end]]
    mux := http.NewServeMux()
	mux.HandleFunc("/", HndlrHome)
	mux.HandleFunc("/favicon.ico", HndlrFavIcon)

	// Set up Debug URL handlers to practice on simple form
    [[if GenDebugging]]
        mux.HandleFunc("/debug", HndlrDebug)
        mux.HandleFunc("/debugAdd", HndlrDebugAdd)
        mux.HandleFunc("/debugDelete", HndlrDebugDelete)
        mux.HandleFunc("/debugNext", HndlrDebugNext)
        mux.HandleFunc("/debugPrev", HndlrDebugPrev)
        mux.HandleFunc("/debugReset", HndlrDebugReset)
        mux.HandleFunc("/debugUpdate", HndlrDebugUpdate)
    [[end]]

	[[range $t := $d.Tables -]]
	    [[ $tn := $t.TitledName -]]
	    // [[$dn]].[[$tn]] URL handlers for table maintenance
	    _ = hndlr[[$dn]][[$tn]].New(io[[$dn]][[$tn]], RowsPerPage, mux)
	[[ end -]]

	// Start the HTTP Server.
    [[if GenDebugging]]
        log.Printf("\tStarting Server at %s:%s...\n", http_srvr, http_port)
    [[end]]
	srvrStr := fmt.Sprintf("%s:%s", http_srvr, http_port)
    [[ if GenMuxWrapper -]]
        s := &http.Server{
            Addr:    srvrStr,
            Handler: MuxHandlerWrapper(mux),
        }
        log.Fatal(s.ListenAndServe())
    [[ else -]]
	    log.Fatal(http.ListenAndServe(srvrStr, mux))
	[[- end ]]

}

