// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

//  Handle HTTP Events

// Generated: [[Time]]
[[- $dot := .]]
[[- $n := .TD.Data.TitledName]]
[[- $t := .Table]]


package hndlr[[.TD.Data.TitledName]]

import (
	[[ if eq .TD.Data.SqlType "mariadb" ]]
		ERROR - NOT IMPLEMENTED
	[[ else if eq .TD.Data.SqlType "mssql" ]]
	_ "github.com/denisenkom/go-mssqldb"
	[[ else if eq .TD.Data.SqlType "mysql" ]]
		_ "github.com/go-sql-driver/mysql"
	[[ else if eq .TD.Data.SqlType "postgres" ]]
		_ "github.com/lib/pq"
	[[ else if eq .TD.Data.SqlType "sqlite" ]]
	_ "github.com/mattn/go-sqlite3"
	[[ end ]]
	"encoding/csv"
    "fmt"
    "io"
    [[if GenDebugging]]
        "log"
    [[end]]
    //"io"
    "../io[[.TD.Data.TitledName]]"
	"net/http"
	"os"
	"strconv"
	//"strings"
)

    // [[.Table.TitledName]]Req2Struct converts the form values to a struct. FormValue(S) are available
    // for both, GET and POST.  It is just that all your parameters are present in the URL if you use
    // GET.  In general, you should use POST with this function for security reasons.
    func [[.Table.TitledName]]Req2Struct(r *http.Request) (io[[.TD.Data.TitledName]].[[.Table.TitledName]], error) {
        var err         error
        var wrk         string

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]Req2Struct()\n")
            log.Printf("\tr.FormValue: %q\n", r.FormValue)
        [[end]]

        data  := io[[$n]].[[.Table.TitledName]]{}
        [[range $f := .Table.Fields -]]
            [[$f.RValueToStruct "data" -]]
            if err != nil {
                goto exitFunc
            }
        [[end]]

    exitFunc:
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]Req2Struct(%+v, %s)\n", data, ErrorString(err))
        [[end]]
        return data, err
    }

    //============================================================================
    //                                  Row Form Handlers
    //============================================================================

    // [[.Table.TitledName]]Show displays the given record.
    func [[.Table.TitledName]]Show(w http.ResponseWriter, rcd  *io[[$n]].[[.Table.TitledName]], msg string) {
	    var err     error

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]Show(%+v, %s)\n", rcd, msg)
        [[end]]

	    data := struct {
	                Rcd         *io[[$n]].[[.Table.TitledName]]
	                Msg         string
	            }{rcd, msg}
        name := "[[$n]].[[.Table.TitledName]].form.gohtml"
        [[if GenDebugging]]
            log.Printf("\tRcd: %+v\n", data.Rcd)
            log.Printf("\tMsg: %s\n", data.Msg)
            log.Printf("\tname: %s\n", name)
        [[end]]
	    err = Tmpls.ExecuteTemplate(w, name, data)
	    if err != nil {
		    fmt.Fprintf(w, err.Error())
	    }

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]Show(%s)\n", ErrorString(err))
        [[end]]
    }

    // [[.Table.TitledName]]HndlrDelete handles an delete request which comes from
    // the row display form.
    func [[.Table.TitledName]]HndlrDelete(w http.ResponseWriter, r *http.Request) {
        var err     error
        var key     string
	    var rcd     *io[[$n]].[[.Table.TitledName]]

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrDelete(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]
        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrNext(Error:405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Get the key.
	    key = r.FormValue("[[.Table.PrimaryKey.Name]]")
        // if key is not present, assume first record.
        [[if GenDebugging]]
            log.Printf("\tkey: %s\n", key)
        [[end]]
        if key == "" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrNext(Error:400) - No Key\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }

        // Delete the row with data given.
        err = io[[.TD.Data.TitledName]].[[.Table.Name]]RowDelete(key)
	    if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrNext(Error:400) - %s\n", ErrorString(err))
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
	    }

        // Get the next row in the form with status message.
        rcd, _ = io[[.TD.Data.TitledName]].[[.Table.Name]]RowNext(key)

        // Display the row in the form.
        [[.Table.TitledName]]Show(w, rcd, "Row deleted!")

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrDelete(%s)\n", ErrorString(err))
        [[end]]
    }

    // [[.Table.TitledName]]HndlrEmpty displays the table row form with an empty row.
    func [[.Table.TitledName]]HndlrEmpty(w http.ResponseWriter, r *http.Request) {
	    var rcd     *io[[$n]].[[.Table.TitledName]]

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrEmpty(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]
        if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrEmpty(Error:405) - Not GET\n")
        [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Verify any fields that need it.

        // Get the row to display.
        rcd = &io[[$n]].[[.Table.TitledName]]{}

        // Display the row in the form.
        [[.Table.TitledName]]Show(w, rcd, "")

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrEmpty()\n")
        [[end]]
    }

    // [[.Table.TitledName]]HndlrFind handles displaying of the table row form display.
    func [[.Table.TitledName]]HndlrFind(w http.ResponseWriter, r *http.Request) {
        var err     error
        var key     string
	    var rcd     *io[[$n]].[[.Table.TitledName]]

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrFind(%s, %s)\n", r.Method, r.FormValue("key"))
        [[end]]
        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrFind(Error:405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Verify any fields that need it.
	    key = r.FormValue("key")
        // if key is not present, assume first record.
        [[if GenDebugging]]
            log.Printf("\tkey: %s\n", key)
        [[end]]

        // Get the row to display.
        if key == "" {
            rcd, err = io[[.TD.Data.TitledName]].[[.Table.Name]]RowFirst()
        } else {
            rcd, err = io[[.TD.Data.TitledName]].[[.Table.Name]]RowFind(key)
        }
	    if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrFind(Error:400) - %s\n", err.Error())
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
	    }

        // Display the row in the form.
        [[.Table.TitledName]]Show(w, rcd, "")

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrFind()\n")
        [[end]]
    }

    // [[.Table.Name]]HndlrFirst displays the first row.
    func [[.Table.TitledName]]HndlrFirst(w http.ResponseWriter, r *http.Request) {
	    var rcd     *io[[$n]].[[.Table.TitledName]]
        var err     error

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrFirst(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]

        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrFirst(Error:405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Get the next row to display.
        rcd, err = io[[$n]].[[.Table.TitledName]]RowFirst()
	    if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrFirst(Error:400) - No Key\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
	    }

        // Display the row in the form.
        [[.Table.TitledName]]Show(w, rcd, "")


        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrFirst()\n")
        [[end]]
    }

    // [[.Table.TitledName]]HndlrForm displays the raw table row form without data.
    func [[.Table.TitledName]]HndlrForm(w http.ResponseWriter, r *http.Request) {

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrForm(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]
        if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrForm(Error:405) - Not GET\n")
        [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Verify any fields that need it.

        // Get the row to display.

        // Display the row in the form.
	    http.ServeFile(w, r, "./tmpl/[[$n]].[[.Table.TitledName]].form.gohtml")

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrForm()\n")
        [[end]]
    }

    // [[.Table.TitledName]]HndlrIndex handles the display of the table index.
    func [[.Table.TitledName]]HndlrIndex(w http.ResponseWriter, r *http.Request) {

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]HndlrIndex(%s)\n", r.URL.Path)
    [[end]]

        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("[[.Table.TitledName]]HndlrIndex(Error 405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // for all rows {
            // Get the row to display.
            // Display the row index fields.
        // }

        w.Write([]byte("Show table index here..."))
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrIndex()\n")
        [[end]]
    }

    // [[.Table.TitledName]]HndlrInsert handles an add row request which comes from
    // the row display form.
    func [[.Table.TitledName]]HndlrInsert(w http.ResponseWriter, r *http.Request) {
	    var rcd     *io[[$n]].[[.Table.TitledName]]
        var err     error

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrInsert(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]
        if r.Method != "POST" {
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Create a record from the data given.
        data, err := [[.Table.TitledName]]Req2Struct(r)
        if err != nil {
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }

        // Verify any fields that need it.

        // Add the row.
        err = io[[$n]].[[.Table.TitledName]]RowInsert(&data)
        if err != nil {
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }

        // Get the last row as a guess of where the inserted row went.
        rcd, _ = io[[$n]].[[.Table.TitledName]]RowLast()

        // Display the row in the form.
        [[.Table.TitledName]]Show(w, rcd, "Row added!")

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrInsert(%s)\n", ErrorString(err))
        [[end]]
    }

    // [[.Table.Name]]HndlrLast displays the first row.
    func [[.Table.TitledName]]HndlrLast(w http.ResponseWriter, r *http.Request) {
	    var rcd     *io[[$n]].[[.Table.TitledName]]
        var err     error

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrLast(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]

        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrLast(Error:405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Get the next row to display.
        rcd, err = io[[$n]].[[.Table.TitledName]]RowLast()
	    if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrLast(Error:400) - No Key\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
	    }

        // Display the row in the form.
        [[.Table.TitledName]]Show(w, rcd, "")

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrLast()\n")
        [[end]]
    }

    // [[.Table.TitledName]]HndlrNext handles an next request which comes from
    // the row display form and should display the next row from the
    // current one.
    func [[.Table.TitledName]]HndlrNext(w http.ResponseWriter, r *http.Request) {
	    var rcd     *io[[$n]].[[.Table.TitledName]]
        var err     error
        var key     string

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrNext(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]

        // Verify HTTP parameters
        if r.Method != "GET" {
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Get the prior key.
	    key = r.FormValue("[[.Table.PrimaryKey.Name]]")
        [[if GenDebugging]]
            log.Printf("\tkey: %s\n", key)
        [[end]]
        if key == "" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrNext(Error:400) - No Key\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }

        // Get the next row to display.
        rcd, err = io[[$n]].[[.Table.TitledName]]RowNext(key)
	    if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrNext(Error:400) - No Key\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
	    }

        // Display the row in the form.
        [[.Table.TitledName]]Show(w, rcd, "")

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrNext()\n")
        [[end]]
    }

    // [[.Table.Name]]HndlrPrev handles an previous request which comes from
    // the row display form and should display the previous row from the
    // current one.
    func [[.Table.TitledName]]HndlrPrev(w http.ResponseWriter, r *http.Request) {
	    var rcd     *io[[$n]].[[.Table.TitledName]]
        var err     error
        var key     string

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrPrev(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]

        if r.Method != "GET" {
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Get the prior key.
	    key = r.FormValue("[[.Table.PrimaryKey.Name]]")
        [[if GenDebugging]]
            log.Printf("\tkey: %s\n", key)
        [[end]]
        if key == "" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrPrev(Error:400) - No Key\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }

        // Get the next row to display.
        rcd, err = io[[$n]].[[.Table.TitledName]]RowPrev(key)
	    if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrNext(Error:400) - No Key\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
	    }

        // Display the row in the form.
        [[.Table.TitledName]]Show(w, rcd, "")


        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrPrev()\n")
        [[end]]
    }

    // [[.Table.TitledName]]HndlrShow handles displaying of the table row form display.
    func [[.Table.TitledName]]HndlrShow(w http.ResponseWriter, r *http.Request) {
        var err     error
        var key     string
	    var rcd     *io[[$n]].[[.Table.TitledName]]

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrShow(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]
        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrShow(Error:405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Verify any fields that need it.
	    key = r.FormValue("[[.Table.PrimaryKey.Name]]")
        // if key is not present, assume first record.
        [[if GenDebugging]]
            log.Printf("\tkey: %s\n", key)
        [[end]]

        // Get the row to display.
        if key == "" {
            rcd, err = io[[.TD.Data.TitledName]].[[.Table.Name]]RowFirst()
        } else {
            rcd, err = io[[.TD.Data.TitledName]].[[.Table.Name]]RowFind(key)
        }
	    if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrShow(Error:400) - %s\n", err.Error())
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
	    }

        // Display the row in the form.
        [[.Table.TitledName]]Show(w, rcd, "")

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrShow()\n")
        [[end]]
    }

    // [[.Table.TitledName]]HndlrUpdate handles an update request which comes from
    // the row display form.
    func [[.Table.TitledName]]HndlrUpdate(w http.ResponseWriter, r *http.Request) {
        var err     error
        var key     string

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrUpdate(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]

        if r.Method != "POST" {
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        [[/* I chose to use delete/insert logic here since I already had it done and the sql update command */]]
        [[/* is much different than insert. Right now, we are accessing the rows using an index. So, delete/insert */]]
        [[/* will work fine for now. */]]

        // Verify any fields that need it.
	    key = r.FormValue("[[.Table.PrimaryKey.Name]]")
        // if key is not present, assume first record.
        [[if GenDebugging]]
            log.Printf("\tkey: %s\n", key)
        [[end]]
        if key == "" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrUpdate(Error:400) - No Key\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }

        // Delete the row.
        err = io[[.TD.Data.TitledName]].[[.Table.Name]]RowDelete(key)
	    if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrNext(Error:400) - %s\n", ErrorString(err))
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
	    }

        // Create a record from the data given.
        data, err := [[.Table.TitledName]]Req2Struct(r)
        if err != nil {
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }

        // Add the row.
        err = io[[$n]].[[.Table.TitledName]]RowInsert(&data)
        if err != nil {
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }

        // Display the next row in the form.
        [[.Table.TitledName]]Show(w, &data, "Record updated")

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrUpdate()\n")
        [[end]]
    }

    //============================================================================
    //                              List Form Handlers
    //============================================================================

    // [[.Table.TitledName]]ShowList displays a list page given a starting offset.
    func [[.Table.TitledName]]ShowList(w http.ResponseWriter, offset int) {
	    var err     error
	    var rcds    []io[[$n]].[[.Table.TitledName]]
        var name    = "[[$n]].[[.Table.TitledName]].list.gohtml"

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]ShowList(%d)\n", offset)
            log.Printf("\tname: %s\n", name)
        [[end]]

	    // Get the records to display
        rcds, err = io[[$n]].[[.Table.TitledName]]RowPage(offset, RowsPerPage)
	    if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrListFirst(Error:400) - No Key\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
	    }

	    data := struct {
	                Rcds        []io[[$n]].[[.Table.TitledName]]
	                Offset      int
	            }{rcds, offset}

        [[if GenDebugging]]
            log.Printf("\tData: %q\n", data)
        [[end]]

	    err = Tmpls.ExecuteTemplate(w, name, data)
	    if err != nil {
		    fmt.Fprintf(w, err.Error())
	    }

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]ShowList(%s)\n", ErrorString(err))
        [[end]]
    }

    // [[.Table.Name]]HndlrListFirst displays the first page of rows.
    func [[.Table.TitledName]]HndlrListFirst(w http.ResponseWriter, r *http.Request) {

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrListFirst(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]

        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrListFirst(Error:405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Display the row in the form.
        [[.Table.TitledName]]ShowList(w, 0)


        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrListFirst()\n")
        [[end]]
    }

    // [[.Table.Name]]HndlrListLast displays the last page of rows.
    func [[.Table.TitledName]]HndlrListLast(w http.ResponseWriter, r *http.Request) {
        var err     error
        var offset  int

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrListLast(%s)\n", r.Method)
        [[end]]

        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrListLast(Error:405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Calculate the offset.
        offset, err = io[[$n]].[[.Table.TitledName]]TableCount()
        if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrListLast(Error:400) - %s\n", err)
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
        }
        offset -= RowsPerPage
        if offset < 0 {
            offset = 0
        }

        // Display the row in the form.
        [[.Table.TitledName]]ShowList(w, offset)


        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrListLast()\n")
        [[end]]
    }

    // [[.Table.Name]]HndlrListNext displays the next page of rows.
    func [[.Table.TitledName]]HndlrListNext(w http.ResponseWriter, r *http.Request) {
        var err     error
        var offset  int
        var cTable  int

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrListNext(%s, %s)\n", r.Method, r.FormValue("[[.Table.PrimaryKey.Name]]"))
        [[end]]

        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrListNext(Error:405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Calculate the offset.
        cTable, err = io[[$n]].[[.Table.TitledName]]TableCount()
        if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrListLast(Error:400) - %s\n", err)
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
        }
        offset, _ = strconv.Atoi(r.FormValue("offset"))
        offset += RowsPerPage
        if offset < 0 || offset > cTable {
            offset = 0
        }

        // Display the row in the form.
        [[.Table.TitledName]]ShowList(w, offset)


        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrListNext()\n")
        [[end]]
    }

    // [[.Table.Name]]HndlrListPrev displays the next page of rows.
    func [[.Table.TitledName]]HndlrListPrev(w http.ResponseWriter, r *http.Request) {
        var err     error
        var offset  int
        var begin   int
        var cTable  int

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrListPrev(%s, %s)\n", r.Method, r.FormValue("offset"))
        [[end]]

        if r.Method != "GET" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrListPrev(Error:405) - Not GET\n")
            [[end]]
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Calculate the offset.
        cTable, err = io[[$n]].[[.Table.TitledName]]TableCount()
        if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrListLast(Error:400) - %s\n", err)
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
        }
        begin, _ = strconv.Atoi(r.FormValue("offset"))
        offset = begin - RowsPerPage
        if offset < 0 {
            if begin > 0 {
                offset = 0
            } else {
                offset = cTable - RowsPerPage
                if offset < 0 {
                    offset = 0
                }
            }
        }

        // Display the row in the form.
        [[.Table.TitledName]]ShowList(w, offset)


        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrListPrev()\n")
        [[end]]
    }

    //============================================================================
    //                             Table Form Handlers
    //============================================================================

    // [[.Table.TitledName]]HndlrTableCreate creates the table deleting any
    // current ones.
    func [[.Table.TitledName]]HndlrTableCreate(w http.ResponseWriter, r *http.Request) {
        var err         error

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrCreate(%s)\n", r.Method)
        [[end]]

        // Verify HTTP parameters
        if r.Method != "GET" {
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Create the table.
        err = io[[$n]].[[.Table.TitledName]]TableCreate()
        if err == nil {
            w.Write([]byte("Table was created"))
        } else {
            w.Write([]byte("Table creation had an error of:" + err.Error()))
        }

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrCreate(%s)\n", ErrorString(err))
        [[end]]
    }

    // [[.Table.TitledName]]HndlrTableLoad creates the table deleting any
    // current ones and loads in some test rows.
    func [[.Table.TitledName]]HndlrTableLoad(w http.ResponseWriter, r *http.Request) {
        var err         error
        var rcd         io[[$n]].[[.Table.TitledName]]

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrLoad(%s)\n", r.Method)
        [[end]]

        // Verify HTTP parameters
        if r.Method != "GET" {
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        // Create the table.
        err = io[[$n]].[[.Table.TitledName]]TableCreate()
        if err == nil {
            w.Write([]byte("Table was created\n"))
        } else {
            w.Write([]byte("Table creation had an error of:" + err.Error()))
        }

        // Load the test rows.
        // Now add some records.
        for i := 0; i < 26; i++ {
            chr := 'A' + i
            [[if .Table.PrimaryKey.IsInteger]]
                rcd.[[.Table.PrimaryKey.Name]] = i
            [[else if .Table.PrimaryKey.IsFloat]]
                rcd.[[.Table.PrimaryKey.Name]] = float64(i)
            [[else]]
                rcd.[[.Table.PrimaryKey.Name]] = string(chr)
            [[end]]
            [[range $f := .Table.Fields]]
                [[if $f.IsText]]
                    rcd.[[$f.TitledName]] = string(chr)
                [[end]]
            [[end]]
            err = io[[$n]].[[.Table.TitledName]]RowInsert(&rcd)
            if err == nil {
                str := fmt.Sprintf("Added row: %c\n", chr)
                w.Write([]byte(str))
            } else {
                str := fmt.Sprintf("Table creation had an error of: %c\n", chr)
                w.Write([]byte(str))
            }
        }

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrLoad(%s)\n", ErrorString(err))
        [[end]]
    }

    // [[.Table.TitledName]]HndlrTableLoadCSV creates the table deleting any
    // current ones and loads in data from a CSV file.
    func [[.Table.TitledName]]HndlrTableLoadCSV(w http.ResponseWriter, r *http.Request) {
        var err         error
        var rcd         io[[$n]].[[.Table.TitledName]]
	    var fileIn      *os.File
	    var path        string
	    var cnt         int

        [[if GenDebugging]]
            log.Printf("[[.Table.TitledName]]HndlrLoadCSV(%s)\n", r.Method)
        [[end]]

        // Verify HTTP parameters
        if r.Method != "GET" {
            http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
            return
        }

        path = r.FormValue("path")
        if path == "" {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrTableLoadCSV(Error:400) - Missing Path\n")
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }
        [[if GenDebugging]]
            log.Printf("\tpath = %s\n", path)
        [[end]]

        // Create the csv reader.
        fileIn, err = os.Open(path)
        if err != nil {
            [[if GenDebugging]]
                log.Printf("...end [[.Table.TitledName]]HndlrTableLoadCSV(Error:400) - %s\n", err)
            [[end]]
            http.Error(w, http.StatusText(400), http.StatusBadRequest)
            return
        }
        defer fileIn.Close()
        [[if GenDebugging]]
            log.Printf("\tFile, %s, is open...\n", path)
        [[end]]
        rdr := csv.NewReader(fileIn)

        // Create the table.
        err = io[[$n]].[[.Table.TitledName]]TableCreate()
        if err != nil {
            w.Write([]byte("Table creation had an error of:" + err.Error()))
        }

        [[if GenDebugging]]
            log.Printf("\tLoading data...\n")
        [[end]]
        for {
            record, err := rdr.Read()
            if err == io.EOF {
                break
            }
            if err != nil {
                str := fmt.Sprintf("ERROR: Reading row %d from csv - %s\n", cnt, err.Error())
                w.Write([]byte(str))
                return
            }

            [[ range $f := .Table.Fields ]]
                [[ $i := $t.FieldIndex $f.Name -]]
                [[ $f.GenFromStringArray "rcd" "record" $i ]]
            [[end]]

            err = io[[$n]].[[.Table.TitledName]]RowInsert(&rcd)
            if err != nil {
                str := fmt.Sprintf("ERROR: Table creation had an error of: %s\n", err.Error())
                w.Write([]byte(str))
                return
            }
            cnt++
            [[if GenDebugging]]
                log.Printf("\t...Added row %d\n", cnt)
            [[end]]
        }
        for i := 1; i > 0; i-- {
            str := fmt.Sprintf("Added %d rows\n", cnt)
            w.Write([]byte(str))
        }

        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]HndlrLoadCSV(ok) - %d\n", cnt)
        [[end]]
    }

