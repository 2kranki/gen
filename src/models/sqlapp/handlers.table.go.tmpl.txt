// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

//  Handle HTTP Events

// Generated: [[Time]]
[[- $dot := .]]
[[- $d  := .TD.Data]]
[[- $dn := .TD.Data.TitledName]]
[[- $t  := .Table]]
[[- $tn := .Table.TitledName]]


package hndlr[[$dn]][[$t.TitledName]]

import (
	_ [[.TD.Data.Plugin.Plugin.GenImportString]]
	"../[[$dn]][[$tn]]"
	"encoding/csv"
    "fmt"
    "io"
    [[if GenDebugging]]
        "log"
    [[end]]
    //"io"
    "mime/multipart"
	"net/http"
	"strconv"
	//"strings"
	"sync"
    "text/template"
)

var Tmpls           *template.Template


//============================================================================
//                             Database Interfaces
//============================================================================

type DbRowDeleter interface {
    // RowDelete deletes the row with keys from the provided record, rcd.
    RowDelete(rcd *[[$dn]][[$tn]].[[$tn]]) error
}

type DbRowFinder interface {
    // RowFind searches the Database for a matching row for the keys found in
    // the given record and returns the output in that same record.
    RowFind(rcd *[[$dn]][[$tn]].[[$tn]]) error
}

type DbRowFirster interface {
    // RowFirst returns the first row in the table, [[$tn]].
    // If there are no rows in the table, then a blank/null record is returned
    // without error.
    RowFirst(rcd *[[$dn]][[$tn]].[[$tn]]) error
}

type DbRowInserter interface {
    RowInsert(rcd *[[$dn]][[$tn]].[[$tn]]) error
}

type DbRowLaster interface {
    // RowLast returns the last row in the table, [[$tn]].
    // If there are no rows in the table, then a blank/null record is returned
    // without error.
    RowLast(rcd *[[$dn]][[$tn]].[[$tn]]) error
}

type DbRowNexter interface {
    // RowNext returns the next row from the row given. If row after the current
    // one does not exist, then the first row is returned.
    RowNext(rcd *[[$dn]][[$tn]].[[$tn]]) error
}

type DbRowPager interface {
    // RowPage returns a page of rows where a page size is the 'limit' parameter and
    // 'offset' is the offset into the result set ordered by the main index. Both
    // 'limit' and 'offset' are relative to 1. We return an address to the array
    // rows (structs) so that we don't have the overhead of copying them everwhere.
    RowPage(offset int, limit int) ([][[$dn]][[$tn]].[[$tn]], error)
}

type DbRowPrever interface {
    RowPrev(rcd *[[$dn]][[$tn]].[[$tn]]) error
}

type DbRowUpdater interface {
    RowUpdate(rcd *[[$dn]][[$tn]].[[$tn]]) error
}

type DbTableCounter interface {
    TableCount() (int, error)
}

type DbTableCreater interface {
    TableCreate() error
}

type DbTableDeleter interface {
    TableDelete() error
}

//============================================================================
//                              Miscellaneous
//============================================================================

[[if GenDebugging]]
func ErrorString(err error) string {
    if err == nil {
        return "ok"
    } else {
        return err.Error()
    }
}
[[end]]

//============================================================================
//                              Handlers
//============================================================================

type Handlers struct {
    mu          sync.Mutex
    db          interface{}
    rowsPerPage int
}

//----------------------------------------------------------------------------
//                             Accessors
//----------------------------------------------------------------------------

func (h Handlers) DB() interface{} {
    return h.db
}

func (h Handlers) SetDB(db interface{}) {
    h.db = db
}

func (h Handlers) RowsPerPage() int {
    return h.rowsPerPage
}

func (h Handlers) SetRowsPerPage(r int) {
    h.rowsPerPage = r
}

//----------------------------------------------------------------------------
//                           Setup Handlers
//----------------------------------------------------------------------------

// SetupHandlers creates a Handler object and sets up each of the handlers
// with it given a mux.
func (h Handlers) SetupHandlers(mux *http.ServeMux) {

    [[if GenDebugging]]
        log.Printf("\t[[$tn]].SetupHandlers()\n")
    [[end]]

	    mux.HandleFunc("/[[$tn]]/list/first",         h.ListFirst)
	    mux.HandleFunc("/[[$tn]]",                    h.ListFirst)
	    mux.HandleFunc("/[[$tn]]/list/last",          h.ListLast)
	    mux.HandleFunc("/[[$tn]]/list/next",          h.ListNext)
	    mux.HandleFunc("/[[$tn]]/list/prev",          h.ListPrev)
	    mux.HandleFunc("/[[$tn]]/delete",             h.RowDelete)
	    mux.HandleFunc("/[[$tn]]/empty",              h.RowEmpty)
	    mux.HandleFunc("/[[$tn]]/find",               h.RowFind)
	    mux.HandleFunc("/[[$tn]]/first",              h.RowFirst)
	    mux.HandleFunc("/[[$tn]]/form",               h.RowForm)
	    mux.HandleFunc("/[[$tn]]/insert",             h.RowInsert)
	    mux.HandleFunc("/[[$tn]]/last",               h.RowLast)
	    mux.HandleFunc("/[[$tn]]/next",               h.RowNext)
	    mux.HandleFunc("/[[$tn]]/prev",               h.RowPrev)
	    mux.HandleFunc("/[[$tn]]/show",               h.RowShow)
	    mux.HandleFunc("/[[$tn]]/update",             h.RowUpdate)
	    mux.HandleFunc("/[[$tn]]/table/create",       h.TableCreate)
	    mux.HandleFunc("/[[$tn]]/table/load/csv",     h.TableLoadCSV)
	    mux.HandleFunc("/[[$tn]]/table/load/test",    h.TableLoadTestData)

    [[if GenDebugging]]
        log.Printf("\tend of [[$tn]].SetupHandlers()\n")
    [[end]]
}

//============================================================================
//                              List Form Handlers
//============================================================================

//----------------------------------------------------------------------------
//                             List First
//----------------------------------------------------------------------------

// ListFirst displays the first page of rows.
func (h Handlers) ListFirst(w http.ResponseWriter, r *http.Request) {

    [[if GenDebugging]]
        log.Printf("[[$tn]].ListFirst(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].ListFirst(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }

    // Display the row in the form.
    h.ListShow(w, 0)

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].ListFirst()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             List Last
//----------------------------------------------------------------------------

// ListLast displays the last page of rows.
func (h Handlers) ListLast(w http.ResponseWriter, r *http.Request) {
    var err     error
    var offset  int
    var counter DbTableCounter
    var ok      bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].ListLast(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].ListLast(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if counter, ok = h.db.(DbTableCounter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Calculate the offset.
    offset, err = counter.TableCount()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].ListLast(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
    }
    offset -= h.rowsPerPage
    if offset < 0 {
        offset = 0
    }

    // Display the row in the form.
    h.ListShow(w, offset)

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].ListLast()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             List Next
//----------------------------------------------------------------------------

// ListNext displays the next page of rows.
func (h Handlers) ListNext(w http.ResponseWriter, r *http.Request) {
    var err     error
    var offset  int
    var cTable  int
    var counter DbTableCounter
    var ok      bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].ListNext(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].ListNext(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if counter, ok = h.db.(DbTableCounter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Calculate the offset.
    cTable, err = counter.TableCount()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].ListLast(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
    }
    offset, _ = strconv.Atoi(r.FormValue("offset"))
    offset += h.rowsPerPage
    if offset < 0 || offset > cTable {
        offset = 0
    }

    // Display the row in the form.
    h.ListShow(w, offset)

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].ListNext()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             List Prev
//----------------------------------------------------------------------------

// ListPrev displays the next page of rows.
func (h Handlers) ListPrev(w http.ResponseWriter, r *http.Request) {
    var err     error
    var offset  int
    var begin   int
    var cTable  int
    var counter DbTableCounter
    var ok      bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].ListPrev(%s, %s)\n", r.Method, r.FormValue("offset"))
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].ListPrev(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if counter, ok = h.db.(DbTableCounter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Calculate the offset.
    cTable, err = counter.TableCount()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].ListLast(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
    }
    begin, _ = strconv.Atoi(r.FormValue("offset"))
    offset = begin - h.rowsPerPage
    if offset < 0 {
        if begin > 0 {
            offset = 0
        } else {
            offset = cTable - h.rowsPerPage
            if offset < 0 {
                offset = 0
            }
        }
    }

    // Display the row in the form.
    h.ListShow(w, offset)

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].ListPrev()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             List Show
//----------------------------------------------------------------------------

// ListShow displays a list page given a starting offset.
func (h Handlers) ListShow(w http.ResponseWriter, offset int) {
    var err     error
    var rcds    [][[$dn]][[$tn]].[[$tn]]
    var name    = "[[$dn]].[[$tn]].list.gohtml"

    [[if GenDebugging]]
        log.Printf("[[$tn]].ListShow(%d)\n", offset)
        log.Printf("\tname: %s\n", name)
    [[end]]

    // Get the records to display
    //TODO: rcds, err = io[[$dn]].[[$tn]]RowPage(offset, h.rowsPerPage)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].ListShow(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    data := struct {
                Rcds        [][[$dn]][[$tn]].[[$tn]]
                Offset      int
            }{rcds, offset}

    [[if GenDebugging]]
        log.Printf("\tData: %q\n", data)
    [[end]]

    err = Tmpls.ExecuteTemplate(w, name, data)
    if err != nil {
        fmt.Fprintf(w, err.Error())
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].ListShow(%s)\n", ErrorString(err))
    [[end]]
}

//============================================================================
//                             Row Form Handlers
//============================================================================

//----------------------------------------------------------------------------
//                             Row Delete
//----------------------------------------------------------------------------

// RowDelete handles an delete request which comes from the row display form.
func (h Handlers) RowDelete(w http.ResponseWriter, r *http.Request) {
    var err     error
    var keys    []string
    var rcd     [[$dn]][[$tn]].[[$tn]]
    var deleter DbRowDeleter
    var nexter  DbRowNexter
    var ok      bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowDelete(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowDelete(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if deleter, ok = h.db.(DbRowDeleter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if nexter, ok = h.db.(DbRowNexter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Construct the keys in the record.
    // Note: For GET, there is no Form or PostForm data since both of those
    // are related to PUT or POST.  The URL contains any data passed in it.
    // Fortunately, the parsed URL is available in the Http Request. So, we
    // get the keys from there.
    if keys, ok = r.URL.Query()["key"]; !ok {
         [[if GenDebugging]]
             log.Printf("...end RowDelete(Error:400) - No keys\n")
         [[end]]
         http.Error(w, http.StatusText(400), http.StatusBadRequest)
         return
    }
    if len(keys) != [[$t.KeyCount]] {
        [[if GenDebugging]]
            log.Printf("...end RowDelete(Error:400) - Invalid Number of keys - %d\n", len(keys))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    [[if GenDebugging]]
        log.Printf("\tkeys: %+v\n", keys)
    [[end]]
    if err = rcd.SetKeysFromStrings(keys); err != nil {
        [[if GenDebugging]]
            log.Printf("...end RowDelete(Error:400) - %s\n", err.Error())
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Delete the row with data given.
    err = deleter.RowDelete(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowDelete(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Get the next row in the form with status message and display it.
    err = nexter.RowNext(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowDelete(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, "Row deleted!")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowDelete(%s)\n", ErrorString(err))
    [[end]]
}

//----------------------------------------------------------------------------
//                                Row Display
//----------------------------------------------------------------------------

// RowDisplay displays the given record.
func (h Handlers) RowDisplay(w http.ResponseWriter, rcd  *[[$dn]][[$tn]].[[$tn]], msg string) {
    var err     error

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowDisplay(%+v, %s)\n", rcd, msg)
    [[end]]

    if Tmpls != nil {
        data := struct {
                    Rcd         *[[$dn]][[$tn]].[[$tn]]
                    Msg         string
                }{rcd, msg}
        name := "[[$dn]].[[$tn]].form.gohtml"
        [[if GenDebugging]]
            log.Printf("\tRcd: %+v\n", data.Rcd)
            log.Printf("\tMsg: %s\n", data.Msg)
            log.Printf("\tname: %s\n", name)
        [[end]]
        err = Tmpls.ExecuteTemplate(w, name, data)
        if err != nil {
            fmt.Fprintf(w, err.Error())
        }
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowDisplay(%s)\n", ErrorString(err))
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Empty
//----------------------------------------------------------------------------

// RowEmpty displays the table row form with an empty row.
func (h Handlers) RowEmpty(w http.ResponseWriter, r *http.Request) {
    var rcd     [[$dn]][[$tn]].[[$tn]]

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowEmpty(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowEmpty(Error:405) - Not GET\n")
    [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }

    // Get the row to display and display it.
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowEmpty()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Find
//----------------------------------------------------------------------------

// RowFind handles displaying of the table row form display.
func (h Handlers) RowFind(w http.ResponseWriter, r *http.Request) {
    var err     error
    var keys    []string
    var rcd     [[$dn]][[$tn]].[[$tn]]
    var finder  DbRowFinder
    var firster DbRowFirster
    var ok      bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowFind(%s, %s)\n", r.Method, r.FormValue("key"))
    [[end]]
    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowFind(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if finder, ok = h.db.(DbRowFinder); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if firster, ok = h.db.(DbRowFirster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Construct the keys in the record.
    // Note: For GET, there is no Form or PostForm data since both of those
    // are related to PUT or POST.  The URL contains any data passed in it.
    // Fortunately, the parsed URL is available in the Http Request. So, we
    // get the keys from there.
    if keys, ok = r.URL.Query()["key"]; !ok {
         [[if GenDebugging]]
             log.Printf("...end RowDelete(Error:400) - No keys\n")
         [[end]]
         http.Error(w, http.StatusText(400), http.StatusBadRequest)
         return
    }
    if len(keys) != [[$t.KeyCount]] {
        [[if GenDebugging]]
            log.Printf("...end RowDelete(Error:400) - Invalid Number of keys - %d\n", len(keys))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    [[if GenDebugging]]
        log.Printf("\tkeys: %+v\n", keys)
    [[end]]
    if err = rcd.SetKeysFromStrings(keys); err != nil {
        [[if GenDebugging]]
            log.Printf("...end RowDelete(Error:400) - %s\n", err.Error())
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Get the row and display it.
    if len(keys) == [[$t.KeyCount]] {
        err = finder.RowFind(&rcd)
    } else {
        err = firster.RowFirst(&rcd)
    }
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowFind(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowFind()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row First
//----------------------------------------------------------------------------

// RowFirst displays the first row.
func (h Handlers) RowFirst(w http.ResponseWriter, r *http.Request) {
    var rcd     [[$dn]][[$tn]].[[$tn]]
    var err     error
    var firster DbRowFirster
    var ok      bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowFirst(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowFirst(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if firster, ok = h.db.(DbRowFirster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the next row and display it.
    err = firster.RowFirst(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowFirst(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, "")


    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowFirst()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Form
//----------------------------------------------------------------------------

// RowForm displays the raw table row form without data.
func (h Handlers) RowForm(w http.ResponseWriter, r *http.Request) {

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowForm(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowForm(Error:405) - Not GET\n")
    [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }

    // Verify any fields that need it.

    // Get the row to display.

    // Display the row in the form.
    http.ServeFile(w, r, "./tmpl/[[$dn]].[[$tn]].form.gohtml")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowForm()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Insert
//----------------------------------------------------------------------------

// RowInsert handles an add row request which comes from the row display form.
func (h Handlers) RowInsert(w http.ResponseWriter, r *http.Request) {
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var err         error
    var inserter    DbRowInserter
    var laster      DbRowLaster
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowInsert(%s)\n", r.Method)
    [[end]]
    if r.Method != "POST" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if inserter, ok = h.db.(DbRowInserter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if laster, ok = h.db.(DbRowLaster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Create a record from the data given.
    err = rcd.Request2Struct(r)
    if err != nil {
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Verify any fields that need it.

    // Add the row.
    err = inserter.RowInsert(&rcd)
    if err != nil {
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Get the last row as a guess of where the inserted row went and display it.
    _ = laster.RowLast(&rcd)
    h.RowDisplay(w, &rcd, "Row added!")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowInsert(%s)\n", ErrorString(err))
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Last
//----------------------------------------------------------------------------

// RowLast displays the first row.
func (h Handlers) RowLast(w http.ResponseWriter, r *http.Request) {
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var err         error
    var laster      DbRowLaster
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowLast(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowLast(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if laster, ok = h.db.(DbRowLaster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the next row to display.
    err = laster.RowLast(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowLast(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Display the row in the form.
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowLast()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Next
//----------------------------------------------------------------------------

// RowNext handles an next request which comes from the row display form and
// should display the next row from the current one.
func (h Handlers) RowNext(w http.ResponseWriter, r *http.Request) {
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var err         error
    var key         string
    var nexter      DbRowNexter
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowNext(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if nexter, ok = h.db.(DbRowNexter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the prior key.
    //key = r.FormValue("[.Table.PrimaryKey.Name]")
    [[if GenDebugging]]
        log.Printf("\tkey: %s\n", key)
    [[end]]
    if key == "" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowNext(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Get the next row and display it.
    err = nexter.RowNext(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowNext(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowNext()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Prev
//----------------------------------------------------------------------------

// RowPrev handles an previous request which comes from the row display form
// and should display the previous row from the current one.
func (h Handlers) RowPrev(w http.ResponseWriter, r *http.Request) {
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var err         error
    var key         string
    var prever      DbRowPrever
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowPrev(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if prever, ok = h.db.(DbRowPrever); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the prior key.
    //key = r.FormValue("[.Table.PrimaryKey.Name]")
    [[if GenDebugging]]
        log.Printf("\tkey: %s\n", key)
    [[end]]
    if key == "" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowPrev(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Get the next row and display it.
    err = prever.RowPrev(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowNext(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowPrev()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Show
//----------------------------------------------------------------------------

// RowShow handles displaying of the table row form display.
func (h Handlers) RowShow(w http.ResponseWriter, r *http.Request) {
    var err         error
    var key         string
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var finder      DbRowFinder
    var firster     DbRowFirster
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowShow(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]]HndlrShow(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if finder, ok = h.db.(DbRowFinder); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if firster, ok = h.db.(DbRowFirster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Verify any fields that need it.
    //TODO: key = r.FormValue("[.Table.PrimaryKey.Name]")
    //TODO: if key is not present, assume first record.
    [[if GenDebugging]]
        //TODO: log.Printf("\tkey: %s\n", key)
    [[end]]

    // Get the row to display.
    if key == "" {
        err = firster.RowFirst(&rcd)
    } else {
        err = finder.RowFind(&rcd)
    }
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowShow(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Display the row in the form.
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowShow()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Update
//----------------------------------------------------------------------------

// RowUpdate handles an update request which comes from the row display form.
func (h Handlers) RowUpdate(w http.ResponseWriter, r *http.Request) {
    var err         error
    var key         string
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var deleter     DbRowDeleter
    var inserter    DbRowInserter
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].RowUpdate(%s)\n", r.Method)
    [[end]]
    if r.Method != "POST" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if deleter, ok = h.db.(DbRowDeleter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if inserter, ok = h.db.(DbRowInserter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    [[/* I chose to use delete/insert logic here since I already had it done and the sql update command */]]
    [[/* is much different than insert. Right now, we are accessing the rows using an index. So, delete/insert */]]
    [[/* will work fine for now. */]]

    // Verify any fields that need it.
    //TODO: key = r.FormValue("[.Table.PrimaryKey.Name]")
    // if key is not present, assume first record.
    [[if GenDebugging]]
        log.Printf("\tkey: %s\n", key)
    [[end]]
    if key == "" {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowUpdate(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Delete the row.
    err = deleter.RowDelete(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowNext(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Create a record from the data given.
    err = rcd.Request2Struct(r)
    if err != nil {
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Add the row.
    err = inserter.RowInsert(&rcd)
    if err != nil {
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Display the next row in the form.
    h.RowDisplay(w, &rcd, "Record updated")

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].RowUpdate()\n")
    [[end]]
}

//============================================================================
//                             Table Form Handlers
//============================================================================

//----------------------------------------------------------------------------
//                             Table Create
//----------------------------------------------------------------------------

// TableCreate creates the table deleting any current ones.
func (h Handlers) TableCreate(w http.ResponseWriter, r *http.Request) {
    var err         error
    var creater     DbTableCreater
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].TableCreate(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if creater, ok = h.db.(DbTableCreater); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Create the table.
    err = creater.TableCreate()
    if err == nil {
        w.Write([]byte("Table was created"))
    } else {
        w.Write([]byte("Table creation had an error of:" + err.Error()))
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].TableCreate(%s)\n", ErrorString(err))
    [[end]]
}

//----------------------------------------------------------------------------
//                            Table Load CSV
//----------------------------------------------------------------------------

// TableLoadCSV creates the table deleting any current ones and loads in
// data from a CSV file.
func (h Handlers) TableLoadCSV(w http.ResponseWriter, r *http.Request) {
    var err         error
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var fileIn      multipart.File
    var cnt         int
    var maxMem      int64
    var inserter    DbRowInserter
    var creater     DbTableCreater
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].TableLoadCSV(%s)\n", r.Method)
    [[end]]
    if r.Method != "POST" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if inserter, ok = h.db.(DbRowInserter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if creater, ok = h.db.(DbTableCreater); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // ParseMultipartForm parses a request body as multipart/form-data.
    // The whole request body is parsed and up to a total of maxMemory
    // bytes of its file parts are stored in memory, with the remainder
    // stored on disk in temporary files. ParseMultipartForm calls ParseForm
    // if necessary. After one call to ParseMultipartForm, subsequent
    // calls have no effect.
    name := "csvFile"           // Must match Name parameter of Form's "<input type=file name=???>"
    maxMem = 64 << 20           // 64mb
    r.ParseMultipartForm(maxMem)

    // FormFile returns the first file for the given key which was
    // specified on the Form Input Type=file Name parameter.
    // it also returns the FileHeader so we can get the Filename,
    // the Header and the size of the file
    fileIn, handler, err := r.FormFile(name)
    if err != nil {
    [[if GenDebugging]]
        log.Printf("...end [[$tn]].TableLoadCSV(Error:500) - %s\n", ErrorString(err))
    [[end]]
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    defer fileIn.Close() //close the file when we finish
    [[if GenDebugging]]
        log.Printf("\tUploaded File: %+v\n", handler.Filename)
        log.Printf("\tFile Size: %+v\n", handler.Size)
        log.Printf("\tMIME Header: %+v\n", handler.Header)
    [[end]]
    rdr := csv.NewReader(fileIn)

    // Create the table.
    err = creater.TableCreate()
    if err != nil {
        w.Write([]byte("Table creation had an error of:" + ErrorString(err)))
    }

    [[if GenDebugging]]
        log.Printf("\tLoading data...\n")
    [[end]]
    for {
        record, err := rdr.Read()
        if err == io.EOF {
            break
        }
        if err != nil {
            str := fmt.Sprintf("ERROR: Reading row %d from csv - %s\n", cnt, ErrorString(err))
            w.Write([]byte(str))
            return
        }

        [[ range $f := .Table.Fields ]]
            [[ $i := $t.FieldIndex $f.Name -]]
            [[ $f.GenFromStringArray "rcd" "record" $i ]]
        [[end]]

        err = inserter.RowInsert(&rcd)
        if err != nil {
            str := fmt.Sprintf("ERROR: Table creation had an error of: %s\n", ErrorString(err))
            w.Write([]byte(str))
            return
        }
        cnt++
        [[if GenDebugging]]
            log.Printf("\t...Added row %d\n", cnt)
        [[end]]
    }
    for i := 1; i > 0; i-- {
        str := fmt.Sprintf("Added %d rows\n", cnt)
        w.Write([]byte(str))
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].TableLoadCSV(ok) - %d\n", cnt)
    [[end]]
}

//----------------------------------------------------------------------------
//                             Table Load Test Data
//----------------------------------------------------------------------------

// TableLoadTestData creates the table deleting any current ones and loads
// in some test rows.
func (h Handlers) TableLoadTestData(w http.ResponseWriter, r *http.Request) {
    var err         error
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var inserter    DbRowInserter
    var creater     DbTableCreater
    var ok          bool

    [[if GenDebugging]]
        log.Printf("[[$tn]].TableLoadTestData(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if inserter, ok = h.db.(DbRowInserter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if creater, ok = h.db.(DbTableCreater); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Create the table.
    err = creater.TableCreate()
    if err == nil {
        w.Write([]byte("Table was created\n"))
    } else {
        w.Write([]byte("Table creation had an error of:" + ErrorString(err)))
    }

[[- if $dot.TD.Data.Plugin.Plugin.NeedUse]]
    // Set USE;
    err = io[[$dn]].DatabaseUse()
    if err == nil {
        w.Write([]byte("USE was issued\n"))
    } else {
        w.Write([]byte("USE had an error of:" + ErrorString(err)))
    }
[[end -]]

    // Load the test rows.
    // Now add some records.
    for i := 0; i < 26; i++ {
        chr := 'A' + i
        //[if .Table.PrimaryKey.IsInteger]
        //    rcd.[.Table.PrimaryKey.TitledName] = int64(i)
        //[else if .Table.PrimaryKey.IsFloat]
        //    rcd.[.Table.PrimaryKey.TitledName] = float64(i)
        //[else]
        //    rcd.[.Table.PrimaryKey.TitledName] = string(chr)
        //[end]
        [[range $f := .Table.Fields]]
            [[if $f.IsText]]
                rcd.[[$f.TitledName]] = string(chr)
            [[else if $f.IsDec]]
                rcd.[[$f.TitledName]] = fmt.Sprintf("%d.00", i)
            [[end]]
        [[end]]
        err = inserter.RowInsert(&rcd)
        if err == nil {
            str := fmt.Sprintf("Added row: %c\n", chr)
            w.Write([]byte(str))
        } else {
            str := fmt.Sprintf("Table creation had an error of: %c\n", chr)
            w.Write([]byte(str))
        }
    }

    [[if GenDebugging]]
        log.Printf("...end [[$tn]].TableLoadTestData(%s)\n", ErrorString(err))
    [[end]]
}

