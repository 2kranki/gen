// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

//  Handle HTTP Events

// Generated: [[Time]]
[[- $dot := .]]
[[- $d  := .TD.Data]]
[[- $dn := .TD.Data.TitledName]]
[[- $t  := .Table]]
[[- $tn := .Table.TitledName]]


package hndlr[[$dn]][[$t.TitledName]]

import (
	_ [[$d.Plugin.Plugin.GenImportString]]
	"../[[$dn]][[$tn]]"
	"encoding/csv"
    "fmt"
    "io"
    [[if GenDebugging]]
        "log"
    [[end]]
    "mime/multipart"
	"net/http"
	"strconv"
    [[if GenDebugging]]
	    "strings"
    [[end]]
	"sync"
    "text/template"
    [[if $t.HasDate]]
	    "time"
	[[end]]
)

var Tmpls           *template.Template


//============================================================================
//                              Miscellaneous
//============================================================================

[[if GenDebugging]]
func ErrorString(err error) string {
    if err == nil {
        return "ok"
    } else {
        return err.Error()
    }
}
[[end]]

//============================================================================
//                        Handlers for [[$dn]].[[$tn]]
//============================================================================

type Handlers struct {
    mu          sync.Mutex
    db          interface{}
    rowsPerPage int
}

//----------------------------------------------------------------------------
//                             Accessors
//----------------------------------------------------------------------------

func (h *Handlers) DB() interface{} {
    return h.db
}

func (h *Handlers) SetDB(db interface{}) {
    h.db = db
}

func (h *Handlers) RowsPerPage() int {
    return h.rowsPerPage
}

func (h *Handlers) SetRowsPerPage(r int) {
    h.rowsPerPage = r
}

//----------------------------------------------------------------------------
//                           Setup Handlers
//----------------------------------------------------------------------------

// SetupHandlers creates a Handler object and sets up each of the handlers
// with it given a mux.
func (h *Handlers) SetupHandlers(mux *http.ServeMux) {

    [[if GenDebugging]]
        log.Printf("\thndlr[[$tn]].SetupHandlers()\n")
    [[end]]

	    mux.HandleFunc("/[[$tn]]/list/first",         h.ListFirst)
	    mux.HandleFunc("/[[$tn]]",                    h.ListFirst)
	    mux.HandleFunc("/[[$tn]]/list/last",          h.ListLast)
	    mux.HandleFunc("/[[$tn]]/list/next",          h.ListNext)
	    mux.HandleFunc("/[[$tn]]/list/prev",          h.ListPrev)
	    mux.HandleFunc("/[[$tn]]/delete",             h.RowDelete)
	    mux.HandleFunc("/[[$tn]]/empty",              h.RowEmpty)
	    mux.HandleFunc("/[[$tn]]/find",               h.RowFind)
	    mux.HandleFunc("/[[$tn]]/first",              h.RowFirst)
	    mux.HandleFunc("/[[$tn]]/form",               h.RowForm)
	    mux.HandleFunc("/[[$tn]]/insert",             h.RowInsert)
	    mux.HandleFunc("/[[$tn]]/last",               h.RowLast)
	    mux.HandleFunc("/[[$tn]]/next",               h.RowNext)
	    mux.HandleFunc("/[[$tn]]/prev",               h.RowPrev)
	    mux.HandleFunc("/[[$tn]]/show",               h.RowShow)
	    mux.HandleFunc("/[[$tn]]/update",             h.RowUpdate)
	    mux.HandleFunc("/[[$tn]]/table/create",       h.TableCreate)
	    mux.HandleFunc("/[[$tn]]/table/load/csv",     h.TableLoadCSV)
	    mux.HandleFunc("/[[$tn]]/table/load/test",    h.TableLoadTestData)

    [[if GenDebugging]]
        log.Printf("\tend of hndlr[[$tn]].SetupHandlers()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                                  New
//----------------------------------------------------------------------------

// New creates a new Handlers object given the parameters needed by the handlers
// and returns it to the caller if successful.  If it fails to properly create
// the handlers then it must fail rather than return an error indicator.
func New(db interface{}, rowsPerPage int, mux *http.ServeMux) *Handlers {
    var h       *Handlers

 	h = &Handlers{db:db, rowsPerPage:rowsPerPage}
    if h == nil {
        log.Fatalf("Error: Unable to allocate Handlers for hndlr[[$dn]][[$tn]]!\n")
    }
    h.SetupHandlers(mux)

    return h
}

//============================================================================
//                              List Form Handlers
//============================================================================

//----------------------------------------------------------------------------
//                             List First
//----------------------------------------------------------------------------

// ListFirst displays the first page of rows.
func (h *Handlers) ListFirst(w http.ResponseWriter, r *http.Request) {

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].ListFirst(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].ListFirst(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }

    // Display the row in the form.
    h.ListShow(w, 0)

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].ListFirst()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             List Last
//----------------------------------------------------------------------------

// ListLast displays the last page of rows.
func (h *Handlers) ListLast(w http.ResponseWriter, r *http.Request) {
    var err     error
    var offset  int
    var counter [[$dn]][[$tn]].DbTableCounter
    var ok      bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].ListLast(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].ListLast(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if counter, ok = h.db.([[$dn]][[$tn]].DbTableCounter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Calculate the offset.
    offset, err = counter.TableCount()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].ListLast(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
    }
    offset -= h.rowsPerPage
    if offset < 0 {
        offset = 0
    }

    // Display the row in the form.
    h.ListShow(w, offset)

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].ListLast()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             List Next
//----------------------------------------------------------------------------

// ListNext displays the next page of rows.
func (h *Handlers) ListNext(w http.ResponseWriter, r *http.Request) {
    var err     error
    var offset  int
    var cTable  int
    var counter [[$dn]][[$tn]].DbTableCounter
    var ok      bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].ListNext(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].ListNext(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if counter, ok = h.db.([[$dn]][[$tn]].DbTableCounter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Calculate the offset.
    cTable, err = counter.TableCount()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].ListLast(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
    }
    offset, _ = strconv.Atoi(r.FormValue("offset"))
    offset += h.rowsPerPage
    if offset < 0 || offset > cTable {
        offset = 0
    }

    // Display the row in the form.
    h.ListShow(w, offset)

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].ListNext()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             List Prev
//----------------------------------------------------------------------------

// ListPrev displays the next page of rows.
func (h *Handlers) ListPrev(w http.ResponseWriter, r *http.Request) {
    var err     error
    var offset  int
    var begin   int
    var cTable  int
    var counter [[$dn]][[$tn]].DbTableCounter
    var ok      bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].ListPrev(%s, %s)\n", r.Method, r.FormValue("offset"))
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].ListPrev(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if counter, ok = h.db.([[$dn]][[$tn]].DbTableCounter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Calculate the offset.
    cTable, err = counter.TableCount()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].ListLast(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
    }
    begin, _ = strconv.Atoi(r.FormValue("offset"))
    offset = begin - h.rowsPerPage
    if offset < 0 {
        if begin > 0 {
            offset = 0
        } else {
            offset = cTable - h.rowsPerPage
            if offset < 0 {
                offset = 0
            }
        }
    }

    // Display the row in the form.
    h.ListShow(w, offset)

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].ListPrev()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             List Show
//----------------------------------------------------------------------------

// ListShow displays a list page given a starting offset.
func (h *Handlers) ListShow(w http.ResponseWriter, offset int) {
    var err     error
    var ok      bool
    var rcds    [][[$dn]][[$tn]].[[$tn]]
    var name    = "[[$dn]].[[$tn]].list.gohtml"
    var pager   [[$dn]][[$tn]].DbRowPager
    [[if GenDebugging]]
        var str     strings.Builder
    [[end]]

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].ListShow(%d)\n", offset)
        log.Printf("\tname: %s\n", name)
        w2 := io.MultiWriter(w, &str)
    [[end]]
    if pager, ok = h.db.([[$dn]][[$tn]].DbRowPager); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the records to display
    rcds, err = pager.RowPage(offset, h.rowsPerPage)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].ListShow(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    data := struct {
                Rcds        [][[$dn]][[$tn]].[[$tn]]
                Offset      int
            }{rcds, offset}

    [[if GenDebugging]]
        log.Printf("\tData: %q\n", data)
    [[end]]

    [[if GenDebugging -]]
        log.Printf("\tExecuting template: %s\n", name)
        err = Tmpls.ExecuteTemplate(w2, name, data)
    [[else]]
        err = Tmpls.ExecuteTemplate(w, name, data)
    [[end -]]
    if err != nil {
        fmt.Fprintf(w, err.Error())
    }

    [[if GenDebugging]]
        log.Printf("\t output: %s\n", str.String())
        log.Printf("...end hndlr[[$tn]].ListShow(%s)\n", ErrorString(err))
    [[end]]
}

//============================================================================
//                             Row Form Handlers
//============================================================================

//----------------------------------------------------------------------------
//                             Row Delete
//----------------------------------------------------------------------------

// RowDelete handles an delete request which comes from the row display form.
func (h *Handlers) RowDelete(w http.ResponseWriter, r *http.Request) {
    var err     error
    var rcd     [[$dn]][[$tn]].[[$tn]]
    var deleter [[$dn]][[$tn]].DbRowDeleter
    var nexter  [[$dn]][[$tn]].DbRowNexter
    var ok      bool
    var i       int
    var key     string

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowDelete(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowDelete(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if deleter, ok = h.db.([[$dn]][[$tn]].DbRowDeleter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if nexter, ok = h.db.([[$dn]][[$tn]].DbRowNexter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the key(s).
    i = 0
    [[range $k := $t.Keys -]]
        [[ $f := $t.FindField $k -]]
        key = r.FormValue(fmt.Sprintf("key%d", i))
        [[$f.GenFromString "rcd" "key"]]
        i++
    [[- end]]
    [[if GenDebugging]]
        log.Printf("\t rcd: %+v\n", rcd)
    [[end]]

    // Delete the row with data given.
    err = deleter.RowDelete(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowDelete(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Get the next row in the form with status message and display it.
    err = nexter.RowNext(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowDelete(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, "Row deleted!")

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowDelete(%s)\n", ErrorString(err))
    [[end]]
}

//----------------------------------------------------------------------------
//                                Row Display
//----------------------------------------------------------------------------

// RowDisplay displays the given record.
func (h *Handlers) RowDisplay(w http.ResponseWriter, rcd  *[[$dn]][[$tn]].[[$tn]], msg string) {
    var err     error

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowDisplay(%+v, %s)\n", rcd, msg)
    [[end]]

    if Tmpls != nil {
        data := struct {
                    Rcd         *[[$dn]][[$tn]].[[$tn]]
                    Msg         string
                }{rcd, msg}
        name := "[[$dn]].[[$tn]].form.gohtml"
        [[if GenDebugging]]
            log.Printf("\tRcd: %+v\n", data.Rcd)
            log.Printf("\tMsg: %s\n", data.Msg)
            log.Printf("\tname: %s\n", name)
        [[end]]
        err = Tmpls.ExecuteTemplate(w, name, data)
        if err != nil {
            fmt.Fprintf(w, err.Error())
        }
    }

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowDisplay(%s)\n", ErrorString(err))
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Empty
//----------------------------------------------------------------------------

// RowEmpty displays the table row form with an empty row.
func (h *Handlers) RowEmpty(w http.ResponseWriter, r *http.Request) {
    var rcd     [[$dn]][[$tn]].[[$tn]]

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowEmpty(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowEmpty(Error:405) - Not GET\n")
    [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }

    // Get the row to display and display it.
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowEmpty()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Find
//----------------------------------------------------------------------------

// RowFind handles displaying of the table row form display.
func (h *Handlers) RowFind(w http.ResponseWriter, r *http.Request) {
    var err     error
    var rcd     [[$dn]][[$tn]].[[$tn]]
    var finder  [[$dn]][[$tn]].DbRowFinder
    var firster [[$dn]][[$tn]].DbRowFirster
    var ok      bool
    var msg     string
    var i       int
    var key     string

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowFind(%s, %s)\n", r.Method, r.FormValue("key"))
    [[end]]
    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowFind(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if finder, ok = h.db.([[$dn]][[$tn]].DbRowFinder); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if firster, ok = h.db.([[$dn]][[$tn]].DbRowFirster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the key(s).
    i = 0
    [[range $k := $t.Keys -]]
        [[ $f := $t.FindField $k -]]
        key = r.FormValue(fmt.Sprintf("key%d", i))
        [[$f.GenFromString "rcd" "key"]]
        i++
    [[- end]]

    // Get the row and display it.
    err = finder.RowFind(&rcd)
    if err != nil {
        msg = "Row NOT Found!"
        err = firster.RowFirst(&rcd)
    }
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowFind(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, msg)

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowFind()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row First
//----------------------------------------------------------------------------

// RowFirst displays the first row.
func (h *Handlers) RowFirst(w http.ResponseWriter, r *http.Request) {
    var rcd     [[$dn]][[$tn]].[[$tn]]
    var err     error
    var firster [[$dn]][[$tn]].DbRowFirster
    var ok      bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowFirst(%s)\n", r.Method)
    [[end]]

    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowFirst(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if firster, ok = h.db.([[$dn]][[$tn]].DbRowFirster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the next row and display it.
    err = firster.RowFirst(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowFirst(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, "")


    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowFirst()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Form
//----------------------------------------------------------------------------

// RowForm displays the raw table row form without data.
func (h *Handlers) RowForm(w http.ResponseWriter, r *http.Request) {

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowForm(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowForm(Error:405) - Not GET\n")
    [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }

    // Verify any fields that need it.

    // Get the row to display.

    // Display the row in the form.
    http.ServeFile(w, r, "./tmpl/[[$dn]].[[$tn]].form.gohtml")

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowForm()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Insert
//----------------------------------------------------------------------------

// RowInsert handles an add row request which comes from the row display form.
func (h *Handlers) RowInsert(w http.ResponseWriter, r *http.Request) {
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var err         error
    var inserter    [[$dn]][[$tn]].DbRowInserter
    var laster      [[$dn]][[$tn]].DbRowLaster
    var ok          bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowInsert(%s)\n", r.Method)
    [[end]]
    if r.Method != "POST" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if inserter, ok = h.db.([[$dn]][[$tn]].DbRowInserter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if laster, ok = h.db.([[$dn]][[$tn]].DbRowLaster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Create a record from the data given.
    err = rcd.Request2Struct(r)
    if err != nil {
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Verify any fields that need it.

    // Add the row.
    err = inserter.RowInsert(&rcd)
    if err != nil {
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Get the last row as a guess of where the inserted row went and display it.
    _ = laster.RowLast(&rcd)
    h.RowDisplay(w, &rcd, "Row added!")

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowInsert(%s)\n", ErrorString(err))
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Last
//----------------------------------------------------------------------------

// RowLast displays the first row.
func (h *Handlers) RowLast(w http.ResponseWriter, r *http.Request) {
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var err         error
    var laster      [[$dn]][[$tn]].DbRowLaster
    var ok          bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowLast(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowLast(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if laster, ok = h.db.([[$dn]][[$tn]].DbRowLaster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the next row to display.
    err = laster.RowLast(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowLast(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Display the row in the form.
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowLast()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Next
//----------------------------------------------------------------------------

// RowNext handles an next request which comes from the row display form and
// should display the next row from the current one.
func (h *Handlers) RowNext(w http.ResponseWriter, r *http.Request) {
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var err         error
    var nexter      [[$dn]][[$tn]].DbRowNexter
    var ok          bool
    var i           int
    var key         string

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowNext(%s)\n", r.Method)
        log.Printf("\tURL: %q\n", r.URL)
    [[end]]
    if r.Method != "GET" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if nexter, ok = h.db.([[$dn]][[$tn]].DbRowNexter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the prior key(s).
    i = 0
    [[range $k := $t.Keys -]]
        [[ $f := $t.FindField $k -]]
        key = r.FormValue(fmt.Sprintf("key%d", i))
        [[$f.GenFromString "rcd" "key"]]
        i++
    [[- end]]

    // Get the next row and display it.
    err = nexter.RowNext(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowNext(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowNext()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Prev
//----------------------------------------------------------------------------

// RowPrev handles an previous request which comes from the row display form
// and should display the previous row from the current one.
func (h *Handlers) RowPrev(w http.ResponseWriter, r *http.Request) {
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var err         error
    var prever      [[$dn]][[$tn]].DbRowPrever
    var ok          bool
    var i           int
    var key         string

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowPrev(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if prever, ok = h.db.([[$dn]][[$tn]].DbRowPrever); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Get the prior key(s).
    i = 0
    [[range $k := $t.Keys -]]
        [[ $f := $t.FindField $k -]]
        key = r.FormValue(fmt.Sprintf("key%d", i))
        [[$f.GenFromString "rcd" "key"]]
        i++
    [[- end]]

    // Get the next row and display it.
    err = prever.RowPrev(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[$tn]].RowNext(Error:400) - No Key\n")
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowPrev()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Show
//----------------------------------------------------------------------------

// RowShow handles displaying of the table row form display.
func (h *Handlers) RowShow(w http.ResponseWriter, r *http.Request) {
    var err         error
    var key         string
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var finder      [[$dn]][[$tn]].DbRowFinder
    var firster     [[$dn]][[$tn]].DbRowFirster
    var ok          bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowShow(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]]HndlrShow(Error:405) - Not GET\n")
        [[end]]
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if finder, ok = h.db.([[$dn]][[$tn]].DbRowFinder); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if firster, ok = h.db.([[$dn]][[$tn]].DbRowFirster); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Verify any fields that need it.
    //TODO: key = r.FormValue("[.Table.PrimaryKey.Name]")
    //TODO: if key is not present, assume first record.
    [[if GenDebugging]]
        //TODO: log.Printf("\tkey: %s\n", key)
    [[end]]

    // Get the row to display.
    if key == "" {
        err = firster.RowFirst(&rcd)
    } else {
        err = finder.RowFind(&rcd)
    }
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowShow(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Display the row in the form.
    h.RowDisplay(w, &rcd, "")

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowShow()\n")
    [[end]]
}

//----------------------------------------------------------------------------
//                             Row Update
//----------------------------------------------------------------------------

// RowUpdate handles an update request which comes from the row display form.
func (h *Handlers) RowUpdate(w http.ResponseWriter, r *http.Request) {
    var err         error
    var key         string
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var deleter     [[$dn]][[$tn]].DbRowDeleter
    var inserter    [[$dn]][[$tn]].DbRowInserter
    var ok          bool
    var i           int

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].RowUpdate(%s)\n", r.Method)
    [[end]]
    if r.Method != "POST" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if deleter, ok = h.db.([[$dn]][[$tn]].DbRowDeleter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if inserter, ok = h.db.([[$dn]][[$tn]].DbRowInserter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    [[/* I chose to use delete/insert logic here since I already had it done and the sql update command */]]
    [[/* is much different than insert. Right now, we are accessing the rows using an index. So, delete/insert */]]
    [[/* will work fine for now. */]]

    // Get the prior key(s).
    i = 0
    [[range $k := $t.Keys -]]
        [[ $f := $t.FindField $k -]]
        key = r.FormValue(fmt.Sprintf("key%d", i))
        [[$f.GenFromString "rcd" "key"]]
        i++
    [[- end]]

    // Delete the row.
    err = deleter.RowDelete(&rcd)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end hndlr[[$tn]].RowNext(Error:400) - %s\n", ErrorString(err))
        [[end]]
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Create a record from the data given.
    err = rcd.Request2Struct(r)
    if err != nil {
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Add the row.
    err = inserter.RowInsert(&rcd)
    if err != nil {
        http.Error(w, http.StatusText(400), http.StatusBadRequest)
        return
    }

    // Display the next row in the form.
    h.RowDisplay(w, &rcd, "Record updated")

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].RowUpdate()\n")
    [[end]]
}

//============================================================================
//                             Table Form Handlers
//============================================================================

//----------------------------------------------------------------------------
//                             Table Create
//----------------------------------------------------------------------------

// TableCreate creates the table deleting any current ones.
func (h *Handlers) TableCreate(w http.ResponseWriter, r *http.Request) {
    var err         error
    var creater     [[$dn]][[$tn]].DbTableCreater
    var ok          bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].TableCreate(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if creater, ok = h.db.([[$dn]][[$tn]].DbTableCreater); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Create the table.
    err = creater.TableCreate()
    if err == nil {
        w.Write([]byte("Table was created"))
    } else {
        w.Write([]byte("Table creation had an error of:" + err.Error()))
    }

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].TableCreate(%s)\n", ErrorString(err))
    [[end]]
}

//----------------------------------------------------------------------------
//                            Table Load CSV
//----------------------------------------------------------------------------

// TableLoadCSV creates the table deleting any current ones and loads in
// data from a CSV file.
func (h *Handlers) TableLoadCSV(w http.ResponseWriter, r *http.Request) {
    var err         error
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var fileIn      multipart.File
    var cnt         int
    var maxMem      int64
    var inserter    [[$dn]][[$tn]].DbRowInserter
    var creater     [[$dn]][[$tn]].DbTableCreater
    var ok          bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].TableLoadCSV(%s)\n", r.Method)
    [[end]]
    if r.Method != "POST" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if inserter, ok = h.db.([[$dn]][[$tn]].DbRowInserter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if creater, ok = h.db.([[$dn]][[$tn]].DbTableCreater); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // ParseMultipartForm parses a request body as multipart/form-data.
    // The whole request body is parsed and up to a total of maxMemory
    // bytes of its file parts are stored in memory, with the remainder
    // stored on disk in temporary files. ParseMultipartForm calls ParseForm
    // if necessary. After one call to ParseMultipartForm, subsequent
    // calls have no effect.
    name := "csvFile"           // Must match Name parameter of Form's "<input type=file name=???>"
    maxMem = 64 << 20           // 64mb
    r.ParseMultipartForm(maxMem)

    // FormFile returns the first file for the given key which was
    // specified on the Form Input Type=file Name parameter.
    // it also returns the FileHeader so we can get the Filename,
    // the Header and the size of the file
    fileIn, handler, err := r.FormFile(name)
    if err != nil {
    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].TableLoadCSV(Error:500) - %s\n", ErrorString(err))
    [[end]]
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    defer fileIn.Close() //close the file when we finish
    [[if GenDebugging]]
        log.Printf("\tUploaded File: %+v\n", handler.Filename)
        log.Printf("\tFile Size: %+v\n", handler.Size)
        log.Printf("\tMIME Header: %+v\n", handler.Header)
    [[end]]
    rdr := csv.NewReader(fileIn)

    // Create the table.
    err = creater.TableCreate()
    if err != nil {
        w.Write([]byte("Table creation had an error of:" + ErrorString(err)))
    }

    [[if GenDebugging]]
        log.Printf("\tLoading data...\n")
    [[end]]
    for {
        record, err := rdr.Read()
        if err == io.EOF {
            break
        }
        if err != nil {
            str := fmt.Sprintf("ERROR: Reading row %d from csv - %s\n", cnt, ErrorString(err))
            w.Write([]byte(str))
            return
        }

        [[ range $f := .Table.Fields ]]
            [[ $i := $t.FieldIndex $f.Name -]]
            [[ $f.GenFromStringArray "rcd" "record" $i ]]
        [[end]]

        err = inserter.RowInsert(&rcd)
        if err != nil {
            str := fmt.Sprintf("ERROR: Table creation had an error of: %s\n", ErrorString(err))
            w.Write([]byte(str))
            return
        }
        cnt++
        [[if GenDebugging]]
            log.Printf("\t...Added row %d\n", cnt)
        [[end]]
    }
    for i := 1; i > 0; i-- {
        str := fmt.Sprintf("Added %d rows\n", cnt)
        w.Write([]byte(str))
    }

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].TableLoadCSV(ok) - %d\n", cnt)
    [[end]]
}

//----------------------------------------------------------------------------
//                             Table Load Test Data
//----------------------------------------------------------------------------

// TableLoadTestData creates the table deleting any current ones and loads
// in some test rows.
func (h *Handlers) TableLoadTestData(w http.ResponseWriter, r *http.Request) {
    var err         error
    var rcd         [[$dn]][[$tn]].[[$tn]]
    var inserter    [[$dn]][[$tn]].DbRowInserter
    var creater     [[$dn]][[$tn]].DbTableCreater
    var useStmter   [[$dn]][[$tn]].DbDatabaseUser
    var ok          bool

    [[if GenDebugging]]
        log.Printf("hndlr[[$tn]].TableLoadTestData(%s)\n", r.Method)
    [[end]]
    if r.Method != "GET" {
        http.Error(w, http.StatusText(405), http.StatusMethodNotAllowed)
        return
    }
    if inserter, ok = h.db.([[$dn]][[$tn]].DbRowInserter); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if creater, ok = h.db.([[$dn]][[$tn]].DbTableCreater); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }
    if useStmter, ok = h.db.([[$dn]][[$tn]].DbDatabaseUser); !ok {
        http.Error(w, http.StatusText(500), http.StatusInternalServerError)
        return
    }

    // Create the table.
    err = creater.TableCreate()
    if err == nil {
        w.Write([]byte("Table was created\n"))
    } else {
        w.Write([]byte("Table creation had an error of:" + ErrorString(err)))
    }

[[- if $dot.TD.Data.Plugin.Plugin.NeedUse]]
    // Set USE;
    err = useStmter.DatabaseUse()
    if err == nil {
        w.Write([]byte("USE was issued\n"))
    } else {
        w.Write([]byte("USE had an error of:" + ErrorString(err)))
    }
[[end -]]

    // Load the test rows.
    // Now add some records.
    for i := 0; i < 26; i++ {
        chr := 'A' + i
        rcd.TestData(i)
        err = inserter.RowInsert(&rcd)
        if err == nil {
            str := fmt.Sprintf("Added row: %c\n", chr)
            w.Write([]byte(str))
        } else {
            str := fmt.Sprintf("Table creation had an error of: %c\n", chr)
            w.Write([]byte(str))
        }
    }

    [[if GenDebugging]]
        log.Printf("...end hndlr[[$tn]].TableLoadTestData(%s)\n", ErrorString(err))
    [[end]]
}

