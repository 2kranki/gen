// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

//  Handle HTTP Events

// Generated: [[Time]]
[[- $dot := .]]
[[- $d   := .TD.Data]]
[[- $dn  := .TD.Data.TitledName]]


package main

import (
	_ "fmt"
	_ "net/http"
	_ "io"
	_ "io/ioutil"
    "html/template"
    [[if GenDebugging]]
        "log"
    [[end]]
    _ "os"
    "sort"

	_ [[$d.Plugin.Plugin.GenImportString]]
)

type Tmpls[[$dn]]  struct {
    tmplsDir        string
    Tmpls           *template.Template
}


func (Tmpls[[$dn]]) Title(i interface{}) string {
    return "Title() - NOT Implemented"
}

func (Tmpls[[$dn]]) Body(i interface{}) string {
    return "Body() - NOT Implemented"
}

func init() {

}

func (t *Tmpls[[$dn]]) SetTmplsDir(d string) {
    t.tmplsDir = d
}

func NewTmpls[[$dn]]() *Tmpls[[$dn]] {
    t := &Tmpls[[$dn]]{}
    t.tmplsDir = "./tmpl"
    return t
}

//----------------------------------------------------------------------------
//                           Setup Templates
//----------------------------------------------------------------------------

// SetupTmpls initializes the functions used in the templates
// and loads them.
func (t *Tmpls[[$dn]]) SetupTmpls() {
    [[if GenDebugging]]
        var templates   []*template.Template
        var tt          *template.Template
        var names       []string
        var name        string
    [[end]]

    [[if GenDebugging]]
        log.Printf("\tSetupTmpls(%s/*.gohtml)\n", t.tmplsDir)
    [[end]]

    funcs := map[string]interface{}{"Title":t.Title, "Body":t.Body,}
    path := t.tmplsDir + "/*.gohtml"
	t.Tmpls = template.Must(template.New("tmpls").Funcs(funcs).ParseGlob(path))

    [[if GenDebugging]]
        templates = t.Tmpls.Templates()
        for _, tt = range templates {
            names = append(names, tt.Name())
        }
        sort.Strings(names)
        for _, name = range names {
            log.Printf("\t\t template: %s\n", name)
        }
        log.Printf("\tend of SetupTmpls()\n")
    [[end]]
}

