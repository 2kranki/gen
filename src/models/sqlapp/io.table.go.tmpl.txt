// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

// This portion of io[[.TD.Data.TitledName]] handles all the
// i/o and manipulation for the [[.Table.Name]] table. Any
// table manipulation should be added to this package as
// methods in IO_[[.Table.Name]]

// Notes:
//  1. Any Database Query that returns "rows" must have an associated
//      rows.Close(). The best way to handle this is to do the query
//      immediately followed by "defer rows.Close()".  Queries that
//      return a "row" need not be closed.

// Generated: [[Time]]
[[$td := .TD]]
[[- $dot := .]]
[[- $d  := .TD.Data]]
[[- $dn := .TD.Data.TitledName]]
[[- $t  := .Table]]
[[- $tn := .Table.TitledName]]

package io[[$dn]][[$tn]]

import (
    "database/sql"
	"errors"
    _ "github.com/shopspring/decimal"
    [[if GenDebugging]]
        "log"
    [[end]]
	_ "strconv"
	_ [[.TD.Data.Plugin.Plugin.GenImportString]]
	"../[[$dn]][[$tn]]"
)



//============================================================================
//                              Miscellaneous
//============================================================================

[[if GenDebugging]]
func ErrorString(err error) string {
    if err == nil {
        return "ok"
    } else {
        return err.Error()
    }
}
[[end]]

//============================================================================
//                            IO_[[$tn]]
//============================================================================

type IO_[[$tn]] struct {
    dbSql       *sql.DB
}

//----------------------------------------------------------------------------
//                             Row Delete
//----------------------------------------------------------------------------

// RowDelete deletes the row with keys from the provided record, rcd.
func (io *IO_[[$tn]]) RowDelete(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var sqlStmt = "[[GenRowDeleteStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("io[[$tn]].RowDelete()\n")
    [[end]]

	_, err = io.dbSql.Exec(sqlStmt, [[$t.KeysList "rcd." ""]])
	if err != nil {
        [[if GenDebugging]]
            log.Printf("...end io[[$tn]].RowDelete(Error:500) - Internal Error\n")
        [[end]]
		return errors.New("500. Internal Server Error")
	}

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowDelete()\n")
    [[end]]
	return nil
}

//----------------------------------------------------------------------------
//                             Row Find
//----------------------------------------------------------------------------

// RowFind searches the Database for a matching row for the keys found in
// the given record and returns the output in that same record.
func (io *IO_[[$tn]]) RowFind(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var sqlStmt     = "[[GenRowFindStmt $t]]"

    [[if GenDebugging]]
        log.Printf("io[[$tn]].RowFind(%+v)\n", rcd)
    [[end]]

	row := io.dbSql.QueryRow(sqlStmt, [[$t.KeysList "rcd." ""]])

	err = row.Scan([[$t.FieldNameList "&rcd."]])

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowFind(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row First
//----------------------------------------------------------------------------

// RowFirst returns the first row in the table, [[.Table.TitledName]].
// If there are no rows in the table, then a blank/null record is returned
// without error.
func (io *IO_[[$tn]]) RowFirst(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var sqlStmt = "[[GenRowFirstStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("io[[$tn]].RowFirst()\n")
    [[end]]

    row := io.dbSql.QueryRow(sqlStmt)

	err = row.Scan([[$t.FieldNameList "&rcd."]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowFirst(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Row Insert
//----------------------------------------------------------------------------

func (io *IO_[[$tn]]) RowInsert(d *[[$dn]][[$tn]].[[$tn]]) error {
    var err     error
    var sqlStmt = "[[GenRowInsertStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("io[[$tn]].RowInsert(%+v)\n", d)
        log.Printf("\tSQL:\n%s\n", sqlStmt)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = io.dbSql.Exec(sqlStmt, [[$t.InsertNameList "d."]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowInsert(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowInsert(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row Last
//----------------------------------------------------------------------------

func (io *IO_[[$tn]]) RowLast(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var sqlStmt = "[[GenRowLastStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("io[[$tn]].RowLast(%+v)\n", rcd)
    [[end]]

    row := io.dbSql.QueryRow(sqlStmt)

	err = row.Scan([[$t.FieldNameList "&rcd."]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowLast(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Row Next
//----------------------------------------------------------------------------

// RowNext returns the next row from the row given. If row after the current
// one does not exist, then the first row is returned.
func (io *IO_[[$tn]]) RowNext(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var sqlStmt = "[[GenRowNextStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("io[[$tn]].RowNext(%+v)\n", rcd)
    [[end]]

    row := io.dbSql.QueryRow(sqlStmt, [[$t.KeysList "rcd." ""]])

	err = row.Scan([[$t.FieldNameList "&rcd."]])
	if err != nil {
	    err = io.RowFirst(rcd)
	}

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowNext(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Row Page
//----------------------------------------------------------------------------

// RowPage returns a page of rows where a page size is the 'limit' parameter and
// 'offset' is the offset into the result set ordered by the main index. Both
// 'limit' and 'offset' are relative to 1. We return an address to the array
// rows (structs) so that we don't have the overhead of copying them everwhere.
func (io *IO_[[$tn]]) RowPage(offset int, limit int) ([][[$dn]][[$tn]].[[$tn]], error) {
    var err         error
    var sqlStmt = "[[GenRowPageStmt $t]]"
    data := [][[$dn]][[$tn]].[[$tn]]{}

    [[if GenDebugging]]
        log.Printf("io[[$tn]].RowPage(%d,%d)\n",offset,limit)
    [[end]]

    rows, err := io.dbSql.Query(sqlStmt, limit, offset)
	if err != nil {
	    return data, err
	}

	for rows.Next() {
		var rcd     [[$dn]][[$tn]].[[$tn]]
		if err = rows.Scan([[$t.FieldNameList "&rcd."]]); err != nil {
			log.Fatal(err)
		} else {
		    data = append(data, rcd)
		}
	}

	err = rows.Close()

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowPage(%s)\n", ErrorString(err))
    [[end]]
    return data, err
}

//----------------------------------------------------------------------------
//                             Row Prev
//----------------------------------------------------------------------------

func (io *IO_[[$tn]]) RowPrev(rcd *[[$dn]][[$tn]].[[$tn]]) error {
    var err         error
    var sqlStmt = "[[GenRowPrevStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("io[[$tn]].RowPrev(%+v)\n", rcd)
    [[end]]

    row := io.dbSql.QueryRow(sqlStmt, [[$t.KeysList "rcd." ""]])

	err = row.Scan([[$t.FieldNameList "&rcd."]])
	if err != nil {
	    err = io.RowLast(rcd)
	}

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowPrev(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Row Update
//----------------------------------------------------------------------------

func (io *IO_[[$tn]]) RowUpdate(d *[[$dn]][[$tn]].[[$tn]]) error {
    var err     error
    var sqlStmt = "[[GenRowInsertStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("io[[$tn]].RowUpdate(%+v)\n", d)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = io.dbSql.Exec(sqlStmt, [[$t.FieldNameList "d."]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowUpdate(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].RowUpdate(%s)\n", ErrorString(err))
    [[end]]
	return err
}


//----------------------------------------------------------------------------
//                             Table Count
//----------------------------------------------------------------------------

func (io *IO_[[$tn]]) TableCount( ) (int, error) {
    var err         error
    var count       int
    var sqlStmt = "[[GenTableCountStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("io[[$tn]].TableCount()\n")
    [[end]]

    row := io.dbSql.QueryRow(sqlStmt)

	err = row.Scan(&count)
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end io[[$tn]].TableCount(%s) %d\n", ErrorString(err), count)
        [[end]]
        return 0, err
    }

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].TableCount(%s) %d\n", ErrorString(err), count)
    [[end]]
    return count, err
}

//----------------------------------------------------------------------------
//                             Table Create
//----------------------------------------------------------------------------

// TableCreate creates the table in the given database deleting the current
// table if present.
func (io *IO_[[$tn]]) TableCreate() error {
    var sqlStmt = "[[GenTableCreateStmt .Table]]"
    var err     error

    [[if GenDebugging]]
        log.Printf("io[[$tn]].TableCreate()\n")
        log.Printf("\tSQL:\n%s\n", sqlStmt)
    [[end]]

    err = io.TableDelete()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end io[[$tn]].TableCreate(Error:%s)\n", err.Error())
        [[end]]
        return err
    }
    _, err = io.dbSql.Exec(sqlStmt)

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].TableCreate(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Table Delete
//----------------------------------------------------------------------------

// TableDelete deletes the table in the given database if present.
func (io *IO_[[$tn]]) TableDelete() error {
    var sqlStmt = "[[GenTableDeleteStmt .Table]]"
    var err     error

    [[if GenDebugging]]
        log.Printf("io[[$tn]].TableDelete()\n")
        log.Printf("\tSQL:\n%s\n", sqlStmt)
    [[end]]

    _, err = io.dbSql.Exec(sqlStmt)

    [[if GenDebugging]]
        log.Printf("...end io[[$tn]].TableDelete(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                                  New
//----------------------------------------------------------------------------

// New creates a new io struct.
func [[$tn]]New(dbSql *sql.DB) *IO_[[$tn]] {
    db := &IO_[[$tn]]{}
    db.dbSql = dbSql
    return db
}

