// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

// This portion of io[[.TD.Data.TitledName]] handles all the
// i/o and manipulation for the [[.Table.Name]] table.

// Notes:
//  1. Any Database Query that returns "rows" must have an associated
//      rows.Close(). The best way to handle this is to do the query
//      immediately followed by "defer rows.Close()".  Queries that
//      return a "row" need not be closed.

// Generated: [[Time]]
[[$td := .TD]]

package io[[.TD.Data.TitledName]]

import (
    "database/sql"
	"errors"
    [[if or .Table.HasFloat .Table.HasInteger]]
        "fmt"
    [[end]]
    [[if GenDebugging]]
        "log"
    [[end]]
	//"net/http"
	"strconv"
    "strings"
	_ [[.TD.Data.ImportStr]]
)

[[.Table.CreateStruct]]

//============================================================================
//                              Miscellaneous
//============================================================================

// KeyToString converts the primary key field value
// to a string.
func (s [[.Table.TitledName]]) KeyToString() string {
    var str     string

    [[.Table.PrimaryKey.GenToString "str" "s"]]

    return str
}

func (s [[.Table.TitledName]]) ListOutput() string {
	var str strings.Builder
    var wrk string

    [[$t := .Table]]
    [[range $f := .Table.Fields]]
        [[if $f.List]]
            // Field: [[$f.TitledName]]
            str.WriteString("<td>\n")
            [[$f.GenToString "wrk" "s"]]
            [[if $f.PrimaryKey]]
                {
                    fstr := fmt.Sprintf("<a href=\"/[[$t.TitledName]]/find?key=\"%s\">\n", wrk)
                    str.WriteString(fstr)
                }
            [[end]]
            wrk += "\n"
            str.WriteString(wrk)
            [[if $f.PrimaryKey]]
                str.WriteString("</a>\n" )
            [[end]]
            str.WriteString("</td>\n")
        [[end]]
	[[end]]

	return str.String()
}


// [[.Table.TitledName]]New creates a new empty
// struct.
func [[.Table.TitledName]]New() *[[.Table.TitledName]] {
    return &[[.Table.TitledName]]{}
}


//============================================================================
//                        Row Maintenance/Select
//============================================================================

func [[.Table.TitledName]]RowDelete(key string) error {

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowDelete()\n")
    [[end]]

    // Do the SQL deletion.
	_, err := db.Exec("DELETE FROM [[.Table.Name]] WHERE [[.Table.PrimaryKey.Name]] = $1;", key)
	if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]RowDelete(Error:500) - Internal Error\n")
        [[end]]
		return errors.New("500. Internal Server Error")
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowDelete()\n")
    [[end]]
	return nil
}

func [[.Table.TitledName]]RowFind(key string) (*[[.Table.TitledName]], error) {
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowFind(%s)\n", key)
    [[end]]

    if key == "" {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowFind(Error:400) - No Key given\n")
    [[end]]
	    return &data, errors.New("400. Bad Request.")
    }

	row := db.QueryRow("SELECT * FROM [[.Table.Name]] WHERE [[.Table.PrimaryKey.Name]] = $1", key)

	err := row.Scan([[.Table.ScanFields "&data"]])

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowFind(%+v, %s)\n", data, ErrorString(err))
    [[end]]
	return &data, err
}

// [[.Table.TitledName]]RowFirst returns the first row in the table,
// [[.Table.TitledName]].  If there are no rows in the table, then
// a blank/null record is returned without error.
func [[.Table.TitledName]]RowFirst() (*[[.Table.TitledName]], error) {
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowFirst()\n")
    [[end]]

    row := db.QueryRow("SELECT * FROM [[.Table.Name]] ORDER BY [[.Table.PrimaryKey.Name]] LIMIT 1")

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowFirst(%+v,%s)\n", data, ErrorString(err))
    [[end]]
    return &data, err
}

func [[.Table.TitledName]]RowInsert(d *[[.Table.TitledName]]) error {
    var err     error

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowInsert(%+v)\n", d)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = db.Exec("INSERT INTO [[.Table.Name]] ([[.Table.CreateInsertStr]]) VALUES ([[.Table.CreateValueStr]])",
                        [[.Table.ScanFields "d"]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowInsert(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowInsert(%s)\n", ErrorString(err))
    [[end]]
	return err
}

func [[.Table.TitledName]]RowLast() (*[[.Table.TitledName]], error) {
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowLast()\n")
    [[end]]

    row := db.QueryRow("SELECT * FROM [[.Table.Name]] ORDER BY [[.Table.PrimaryKey.Name]] DESC LIMIT 1")

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowLast(%+v, %s)\n",data, ErrorString(err))
    [[end]]
    return &data, err
}

func [[.Table.TitledName]]RowNext(key string) (*[[.Table.TitledName]], error) {
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowNext()\n")
    [[end]]

    row := db.QueryRow("SELECT * FROM [[.Table.Name]] WHERE [[.Table.PrimaryKey.Name]] > $1 ORDER BY [[.Table.PrimaryKey.Name]] ASC LIMIT 1", key)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err != nil {
	    var datap   *[[.Table.TitledName]]
	    datap, err = [[.Table.TitledName]]RowFirst()
	    if datap != nil {
	        data = *datap
	    }
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowNext(%+v, %s)\n", data, ErrorString(err))
    [[end]]
    return &data, err
}

// func [[.Table.TitledName]]RowPage returns a page of rows where a page size is the
// 'limit' parameter and 'offset' is the offset into the result set ordered by the main
// index. Both 'limit' and 'offset' are relative to 1. We return an address to the array
// rows (structs) so that we don't have the overhead of copying them everwhere.
func [[.Table.TitledName]]RowPage(offset int, limit int) ([][[.Table.TitledName]], error) {
    data := [][[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowPage(%d,%d)\n",offset,limit)
    [[end]]

    rows, err := db.Query("SELECT * FROM [[.Table.Name]] ORDER BY [[.Table.PrimaryKey.Name]] ASC LIMIT $1 OFFSET $2 ;", limit, offset)
	if err != nil {
	    return data,err
	}

	for rows.Next() {
		var rcd     [[.Table.TitledName]]
		if err := rows.Scan([[.Table.ScanFields "&rcd"]]); err != nil {
			log.Fatal(err)
		} else {
		    data = append(data, rcd)
		}
	}

	rows.Close()

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowPage(%s)\n", ErrorString(err))
    [[end]]
    return data, err
}

func [[.Table.TitledName]]RowPrev(key string) (*[[.Table.TitledName]], error) {
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowPrev()\n")
    [[end]]

    row := db.QueryRow("SELECT * FROM [[.Table.Name]] WHERE [[.Table.PrimaryKey.Name]] < $1 ORDER BY [[.Table.PrimaryKey.Name]] DESC LIMIT 1", key)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err != nil {
	    var datap   *[[.Table.TitledName]]
	    datap, err = [[.Table.TitledName]]RowLast()
	    if datap != nil {
	        data = *datap
	    }
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowPrev(%s)\n", ErrorString(err))
    [[end]]
    return &data, err
}

func [[.Table.TitledName]]RowUpdate(d *[[.Table.TitledName]]) error {
    var err     error

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowUpdate(%+v)\n", d)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = db.Exec("INSERT INTO [[.Table.Name]] ([[.Table.CreateInsertStr]]) VALUES ([[.Table.CreateValueStr]])",
                        [[.Table.ScanFields "d"]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowUpdate(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowUpdate(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//============================================================================
//                        Table Maintenance/Select
//============================================================================

func [[.Table.TitledName]]TableCount( ) (int, error) {
    var count       int

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]TableCount()\n")
    [[end]]

    row := db.QueryRow("SELECT COUNT(*) FROM [[.Table.Name]]")

	err := row.Scan(&count)

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]TableCount(%s) %d\n", ErrorString(err), count)
    [[end]]
    return count, err
}

// [[.Table.TitledName]]TableCreate creates the table in the
// given database deleting the current table if
// present.
func [[.Table.TitledName]]TableCreate() error {
    var createSql = "[[.Table.CreateSql]]"
    var err     error

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]TableCreate()\n")
    [[end]]

    err = [[.Table.TitledName]]TableDelete()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]TableCreate(Error:%s)\n", err.Error())
        [[end]]
        return err
    }
    _, err = db.Exec(createSql)

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]TableCreate(%s)\n", ErrorString(err))
    [[end]]
    return err
}

// [[.Table.TitledName]]TableDelete deletes the table in the
// given database if present.
func [[.Table.TitledName]]TableDelete() error {
    var deleteSql = "[[.Table.DeleteSql]]"
    var err     error

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]TableDelete()\n")
    [[end]]

    _, err = db.Exec(deleteSql)

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]TableDelete(%s)\n", ErrorString(err))
    [[end]]
    return err
}

