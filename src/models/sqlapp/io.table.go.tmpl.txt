// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

// This portion of io[[.TD.Data.TitledName]] handles all the
// i/o and manipulation for the [[.Table.Name]] table.

// Notes:
//  1. Any Database Query that returns "rows" must have an associated
//      rows.Close(). The best way to handle this is to do the query
//      immediately followed by "defer rows.Close()".  Queries that
//      return a "row" need not be closed.

// Generated: [[Time]]
[[$td := .TD]]

package io[[.TD.Data.TitledName]]

import (
    "database/sql"
	"errors"
	"fmt"
    _ "github.com/shopspring/decimal"
    [[if GenDebugging]]
        "log"
    [[end]]
	//"net/http"
	_ "strconv"
    "strings"
	_ [[.TD.Data.Plugin.Plugin.GenImportString]]
)



//============================================================================
//                              Miscellaneous
//============================================================================

[[.Table.CreateStruct]]

//----------------------------------------------------------------------------
//                             Key to String
//----------------------------------------------------------------------------

// KeyToString converts the primary key field value
// to a string.
func (s [[.Table.TitledName]]) KeyToString() string {
    var str     string

    //[.Table.PrimaryKey.GenToString "str" "s"]

    return str
}

//----------------------------------------------------------------------------
//                             List Output
//----------------------------------------------------------------------------

func (s [[.Table.TitledName]]) ListOutput() string {
	var str strings.Builder
    var wrk string

    [[$t := .Table]]
    [[range $f := .Table.Fields]]
        [[if $f.List]]
            // Field: [[$f.TitledName]]
            str.WriteString("<td>\n")
            [[$f.GenToString "wrk" "s"]]
            //[if $f.PrimaryKey]
            //    {
            //        fstr := fmt.Sprintf("<a href=\"/[[$t.TitledName]]/find?key=\"%s\">\n", wrk)
            //        str.WriteString(fstr)
            //    }
            //[end]
            wrk += "\n"
            str.WriteString(wrk)
            //[if $f.PrimaryKey]
            //    str.WriteString("</a>\n" )
            //[end]
            str.WriteString("</td>\n")
        [[end]]
	[[end]]

	return str.String()
}

//----------------------------------------------------------------------------
//                             New Struct
//----------------------------------------------------------------------------

// [[.Table.TitledName]]New creates a new empty struct.
func [[.Table.TitledName]]New() *[[.Table.TitledName]] {
    return &[[.Table.TitledName]]{}
}


//============================================================================
//                            [[.Table.TitledName]]DB
//============================================================================

type [[.Table.TitledName]]DB struct {
    dbSql       *sql.DB
}

//----------------------------------------------------------------------------
//                             Row Delete
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowDelete(rcd *[[.Table.TitledName]]) error {
    var sqlStmt = "[[GenRowDeleteStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowDelete()\n")
    [[end]]

    // Do the SQL deletion.
	//_, err := db.dbSql.Exec(sqlStmt, key)
	if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]RowDelete(Error:500) - Internal Error\n")
        [[end]]
		return errors.New("500. Internal Server Error")
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowDelete()\n")
    [[end]]
	return nil
}

//----------------------------------------------------------------------------
//                             Row Find
//----------------------------------------------------------------------------

// RowFind searches the Database for a matching row for the keys found in
// the given record and returns the output in that same record.
func (db [[.Table.TitledName]]DB) RowFind(rcd *[[.Table.TitledName]]) error {
    var sqlStmt = "[[GenRowFindStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowFind(%s)\n", key)
    [[end]]

    if key == "" {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowFind(Error:400) - No Key given\n")
    [[end]]
	    return &data, errors.New("400. Bad Request.")
    }

	row := db.dbSql.QueryRow(sqlStmt, key)

	err := row.Scan([[.Table.ScanFields "&data"]])

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowFind(%+v, %s)\n", data, ErrorString(err))
    [[end]]
	return &data, err
}

//----------------------------------------------------------------------------
//                             Row First
//----------------------------------------------------------------------------

// RowFirst returns the first row in the table, [[.Table.TitledName]].
// If there are no rows in the table, then a blank/null record is returned
// without error.
func (db [[.Table.TitledName]]DB) RowFirst() (*[[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowFirstStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowFirst()\n")
    [[end]]

    row := db.dbSql.QueryRow(sqlStmt)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowFirst(%+v,%s)\n", data, ErrorString(err))
    [[end]]
    return &data, err
}

//----------------------------------------------------------------------------
//                             Row Insert
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowInsert(d *[[.Table.TitledName]]) error {
    var err     error
    var sqlStmt = "[[GenRowInsertStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowInsert(%+v)\n", d)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = db.Exec(sqlStmt, [[.Table.ScanFields "d"]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowInsert(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowInsert(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row Last
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowLast() (*[[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowLastStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowLast()\n")
    [[end]]

    row := db.dbSql.QueryRow(sqlStmt)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowLast(%+v, %s)\n",data, ErrorString(err))
    [[end]]
    return &data, err
}

//----------------------------------------------------------------------------
//                             Row Next
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowNext(key string) (*[[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowNextStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowNext()\n")
    [[end]]

    row := db.dbSql.QueryRow(sqlStmt, key)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err != nil {
	    var datap   *[[.Table.TitledName]]
	    datap, err = [[.Table.TitledName]]RowFirst()
	    if datap != nil {
	        data = *datap
	    }
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowNext(%+v, %s)\n", data, ErrorString(err))
    [[end]]
    return &data, err
}

//----------------------------------------------------------------------------
//                             Row Page
//----------------------------------------------------------------------------

// RowPage returns a page of rows where a page size is the 'limit' parameter and
// 'offset' is the offset into the result set ordered by the main index. Both
// 'limit' and 'offset' are relative to 1. We return an address to the array
// rows (structs) so that we don't have the overhead of copying them everwhere.
func (db [[.Table.TitledName]]DB) RowPage(offset int, limit int) ([][[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowPageStmt .Table]]"
    data := [][[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowPage(%d,%d)\n",offset,limit)
    [[end]]

    rows, err := db.dbSql.Query(sqlStmt, limit, offset)
	if err != nil {
	    return data,err
	}

	for rows.Next() {
		var rcd     [[.Table.TitledName]]
		if err := rows.Scan([[.Table.ScanFields "&rcd"]]); err != nil {
			log.Fatal(err)
		} else {
		    data = append(data, rcd)
		}
	}

	rows.Close()

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowPage(%s)\n", ErrorString(err))
    [[end]]
    return data, err
}

//----------------------------------------------------------------------------
//                             Row Prev
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowPrev(key string) (*[[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowPrevStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowPrev()\n")
    [[end]]

    row := db.dbSql.QueryRow(sqlStmt, key)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err != nil {
	    var datap   *[[.Table.TitledName]]
	    datap, err = [[.Table.TitledName]]RowLast()
	    if datap != nil {
	        data = *datap
	    }
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowPrev(%s)\n", ErrorString(err))
    [[end]]
    return &data, err
}

//----------------------------------------------------------------------------
//                             Row Update
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowUpdate(d *[[.Table.TitledName]]) error {
    var err     error
    var sqlStmt = "[[GenRowInsertStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowUpdate(%+v)\n", d)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = db.dbSql.Exec(sqlStmt, [[.Table.ScanFields "d"]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowUpdate(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowUpdate(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                                  New
//----------------------------------------------------------------------------

// [[.Table.TitledName]]NewDB creates a new DB struct.
func [[.Table.TitledName]]New(dbSql *sql.DB) *[[.Table.TitledName]]DB {
    db := [[.Table.TitledName]]DB{}
    db.dbSql = dbSql
    return &db
}


//============================================================================
//                        Row Maintenance/Select
//============================================================================

//----------------------------------------------------------------------------
//                             Row Delete
//----------------------------------------------------------------------------

func [[.Table.TitledName]]RowDelete(key string) error {
    var sqlStmt = "[[GenRowDeleteStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowDelete()\n")
    [[end]]

    // Do the SQL deletion.
	//_, err := db.Exec(sqlStmt, key)
	if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]RowDelete(Error:500) - Internal Error\n")
        [[end]]
		return errors.New("500. Internal Server Error")
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowDelete()\n")
    [[end]]
	return nil
}

//----------------------------------------------------------------------------
//                             Row Find
//----------------------------------------------------------------------------

func [[.Table.TitledName]]RowFind(key string) (*[[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowFindStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowFind(%s)\n", key)
    [[end]]

    if key == "" {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowFind(Error:400) - No Key given\n")
    [[end]]
	    return &data, errors.New("400. Bad Request.")
    }

	row := db.QueryRow(sqlStmt, key)

	err := row.Scan([[.Table.ScanFields "&data"]])

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowFind(%+v, %s)\n", data, ErrorString(err))
    [[end]]
	return &data, err
}

//----------------------------------------------------------------------------
//                             Row First
//----------------------------------------------------------------------------

// [[.Table.TitledName]]RowFirst returns the first row in the table,
// [[.Table.TitledName]].  If there are no rows in the table, then
// a blank/null record is returned without error.
func [[.Table.TitledName]]RowFirst() (*[[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowFirstStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowFirst()\n")
    [[end]]

    row := db.QueryRow(sqlStmt)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowFirst(%+v,%s)\n", data, ErrorString(err))
    [[end]]
    return &data, err
}

//----------------------------------------------------------------------------
//                             Row Insert
//----------------------------------------------------------------------------

func [[.Table.TitledName]]RowInsert(d *[[.Table.TitledName]]) error {
    var err     error
    var sqlStmt = "[[GenRowInsertStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowInsert(%+v)\n", d)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = db.Exec(sqlStmt, [[.Table.ScanFields "d"]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowInsert(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowInsert(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row Last
//----------------------------------------------------------------------------

func [[.Table.TitledName]]RowLast() (*[[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowLastStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowLast()\n")
    [[end]]

    row := db.QueryRow(sqlStmt)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowLast(%+v, %s)\n",data, ErrorString(err))
    [[end]]
    return &data, err
}

//----------------------------------------------------------------------------
//                             Row Next
//----------------------------------------------------------------------------

func [[.Table.TitledName]]RowNext(key string) (*[[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowNextStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowNext()\n")
    [[end]]

    row := db.QueryRow(sqlStmt, key)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err != nil {
	    var datap   *[[.Table.TitledName]]
	    datap, err = [[.Table.TitledName]]RowFirst()
	    if datap != nil {
	        data = *datap
	    }
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowNext(%+v, %s)\n", data, ErrorString(err))
    [[end]]
    return &data, err
}

//----------------------------------------------------------------------------
//                             Row Page
//----------------------------------------------------------------------------

// func [[.Table.TitledName]]RowPage returns a page of rows where a page size is the
// 'limit' parameter and 'offset' is the offset into the result set ordered by the main
// index. Both 'limit' and 'offset' are relative to 1. We return an address to the array
// rows (structs) so that we don't have the overhead of copying them everwhere.
func [[.Table.TitledName]]RowPage(offset int, limit int) ([][[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowPageStmt .Table]]"
    data := [][[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowPage(%d,%d)\n",offset,limit)
    [[end]]

    rows, err := db.Query(sqlStmt, limit, offset)
	if err != nil {
	    return data,err
	}

	for rows.Next() {
		var rcd     [[.Table.TitledName]]
		if err := rows.Scan([[.Table.ScanFields "&rcd"]]); err != nil {
			log.Fatal(err)
		} else {
		    data = append(data, rcd)
		}
	}

	rows.Close()

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowPage(%s)\n", ErrorString(err))
    [[end]]
    return data, err
}

//----------------------------------------------------------------------------
//                             Row Prev
//----------------------------------------------------------------------------

func [[.Table.TitledName]]RowPrev(key string) (*[[.Table.TitledName]], error) {
    var sqlStmt = "[[GenRowPrevStmt .Table]]"
    data := [[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowPrev()\n")
    [[end]]

    row := db.QueryRow(sqlStmt, key)

	err := row.Scan([[.Table.ScanFields "&data"]])
	if err != nil {
	    var datap   *[[.Table.TitledName]]
	    datap, err = [[.Table.TitledName]]RowLast()
	    if datap != nil {
	        data = *datap
	    }
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowPrev(%s)\n", ErrorString(err))
    [[end]]
    return &data, err
}

//----------------------------------------------------------------------------
//                             Row Update
//----------------------------------------------------------------------------

func [[.Table.TitledName]]RowUpdate(d *[[.Table.TitledName]]) error {
    var err     error
    var sqlStmt = "[[GenRowInsertStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]RowUpdate(%+v)\n", d)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = db.Exec(sqlStmt, [[.Table.ScanFields "d"]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowUpdate(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]RowUpdate(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//============================================================================
//                        Table Maintenance/Select
//============================================================================

//----------------------------------------------------------------------------
//                             Table Count
//----------------------------------------------------------------------------

func [[.Table.TitledName]]TableCount( ) (int, error) {
    var count       int
    var sqlStmt = "[[GenTableCountStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]TableCount()\n")
    [[end]]

    row := db.QueryRow(sqlStmt)

	err := row.Scan(&count)

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]TableCount(%s) %d\n", ErrorString(err), count)
    [[end]]
    return count, err
}

//----------------------------------------------------------------------------
//                             Table Create
//----------------------------------------------------------------------------

// [[.Table.TitledName]]TableCreate creates the table in the
// given database deleting the current table if
// present.
func [[.Table.TitledName]]TableCreate() error {
    var sqlStmt = "[[GenTableCreateStmt .Table]]"
    var err     error

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]TableCreate()\n")
        log.Printf("\tSQL:\n%s\n", sqlStmt)
    [[end]]

    err = [[.Table.TitledName]]TableDelete()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]]TableCreate(Error:%s)\n", err.Error())
        [[end]]
        return err
    }
    _, err = db.Exec(sqlStmt)

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]TableCreate(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Table Delete
//----------------------------------------------------------------------------

// [[.Table.TitledName]]TableDelete deletes the table in the
// given database if present.
func [[.Table.TitledName]]TableDelete() error {
    var sqlStmt = "[[GenTableDeleteStmt .Table]]"
    var err     error

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]]TableDelete()\n")
        log.Printf("\tSQL:\n%s\n", sqlStmt)
    [[end]]

    _, err = db.Exec(sqlStmt)

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]]TableDelete(%s)\n", ErrorString(err))
    [[end]]
    return err
}

