// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

// This portion of io[[.TD.Data.TitledName]] handles all the
// i/o and manipulation for the [[.Table.Name]] table.

// Notes:
//  1. Any Database Query that returns "rows" must have an associated
//      rows.Close(). The best way to handle this is to do the query
//      immediately followed by "defer rows.Close()".  Queries that
//      return a "row" need not be closed.

// Generated: [[Time]]
[[$td := .TD]]

package io[[.TD.Data.TitledName]]

import (
    "database/sql"
	"errors"
	"fmt"
    _ "github.com/shopspring/decimal"
    [[if GenDebugging]]
        "log"
    [[end]]
	//"net/http"
	_ "strconv"
    "strings"
	_ [[.TD.Data.Plugin.Plugin.GenImportString]]
)



//============================================================================
//                              Miscellaneous
//============================================================================

[[.Table.CreateStruct]]

//----------------------------------------------------------------------------
//                             List Output
//----------------------------------------------------------------------------

func (s [[.Table.TitledName]]) ListOutput() string {
	var str strings.Builder
    var wrk string

    [[$t := .Table]]
    [[range $f := .Table.Fields]]
        [[if $f.List]]
            // Field: [[$f.TitledName]]
            str.WriteString("<td>\n")
            [[$f.GenToString "wrk" "s"]]
            [[if $f.KeyNum]]
                {
                    fstr := fmt.Sprintf("<a href=\"/[[$t.TitledName]]/find?key=\"%s\">\n", wrk)
                    str.WriteString(fstr)
                }
            [[end]]
            wrk += "\n"
            str.WriteString(wrk)
            [[if $f.KeyNum]]
                str.WriteString("</a>\n" )
            [[end]]
            str.WriteString("</td>\n")
        [[end]]
	[[end]]

	return str.String()
}

//----------------------------------------------------------------------------
//                             Test Data
//----------------------------------------------------------------------------

func (s [[.Table.TitledName]]) TestData(i int) {
    var chr     rune

    if i < 27 {
        chr = rune(65 + i)      // A
    } else if i < 55 {
        chr = rune(97 + i)      // a
    } else {
        chr = rune(65)          // A
    }

    [[$t := .Table]]
    [[range $f := .Table.Fields]]
        [[if $f.IsText]]
            s.[[$f.TitledName]] = string(chr)
        [[else if $f.IsDec]]
            s.[[$f.TitledName]] = int64(i)
        [[else if $f.IsFloat]]
            s.[[$f.TitledName]] = Float64(i)
        [[end]]
	[[end]]

}

//----------------------------------------------------------------------------
//                             New Struct
//----------------------------------------------------------------------------

// [[.Table.TitledName]]New creates a new empty struct.
func [[.Table.TitledName]]New() *[[.Table.TitledName]] {
    return &[[.Table.TitledName]]{}
}


//============================================================================
//                            [[.Table.TitledName]]DB
//============================================================================

type [[.Table.TitledName]]DB struct {
    dbSql       *sql.DB
}

//----------------------------------------------------------------------------
//                             Row Delete
//----------------------------------------------------------------------------

// RowDelete deletes the row with keys from the provided record, rcd.
func (db [[.Table.TitledName]]DB) RowDelete(rcd *[[.Table.TitledName]]) error {
    var err         error
    var sqlStmt = "[[GenRowDeleteStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].RowDelete()\n")
    [[end]]

	//_, err = db.dbSql.Exec(sqlStmt, key)
	if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]].RowDelete(Error:500) - Internal Error\n")
        [[end]]
		return errors.New("500. Internal Server Error")
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowDelete()\n")
    [[end]]
	return nil
}

//----------------------------------------------------------------------------
//                             Row Find
//----------------------------------------------------------------------------

// RowFind searches the Database for a matching row for the keys found in
// the given record and returns the output in that same record.
func (db [[.Table.TitledName]]DB) RowFind(rcd *[[.Table.TitledName]]) error {
    var err         error
    var sqlStmt     = "[[GenRowFindStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].RowFind(%+v)\n", rcd)
    [[end]]

    if key == "" {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowFind(Error:400) - No Key given\n")
    [[end]]
	    return errors.New("400. Bad Request.")
    }

	row := db.dbSql.QueryRow(sqlStmt, key)

	err = row.Scan([[.Table.ScanFields "rcd"]])

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowFind(%+v, %s)\n", data, ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row First
//----------------------------------------------------------------------------

// RowFirst returns the first row in the table, [[.Table.TitledName]].
// If there are no rows in the table, then a blank/null record is returned
// without error.
func (db [[.Table.TitledName]]DB) RowFirst(rcd *[[.Table.TitledName]]) error {
    var err         error
    var sqlStmt = "[[GenRowFirstStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].RowFirst()\n")
    [[end]]

    row := db.dbSql.QueryRow(sqlStmt)

	err = row.Scan([[.Table.ScanFields "rcd"]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowFirst(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Row Insert
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowInsert(d *[[.Table.TitledName]]) error {
    var err     error
    var sqlStmt = "[[GenRowInsertStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].RowInsert(%+v)\n", d)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = db.dbSql.Exec(sqlStmt, [[.Table.ScanFields "d"]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowInsert(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowInsert(%s)\n", ErrorString(err))
    [[end]]
	return err
}

//----------------------------------------------------------------------------
//                             Row Last
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowLast(rcd *[[.Table.TitledName]]) error {
    var err         error
    var sqlStmt = "[[GenRowLastStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].RowLast(%+v)\n", rcd)
    [[end]]

    row := db.dbSql.QueryRow(sqlStmt)

	err = row.Scan([[.Table.ScanFields "rcd"]])
	if err == sql.ErrNoRows {
        [[if GenDebugging]]
            log.Printf("\tNo Rows found!\n")
        [[end]]
	    err = nil
    }

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowLast(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Row Next
//----------------------------------------------------------------------------

// RowNext returns the next row from the row given. If row after the current
// one does not exist, then the first row is returned.
func (db [[.Table.TitledName]]DB) RowNext(rcd *[[.Table.TitledName]]) error {
    var err         error
    var sqlStmt = "[[GenRowNextStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].RowNext(%+v)\n", rcd)
    [[end]]

    row := db.dbSql.QueryRow(sqlStmt, key)

	err = row.Scan([[.Table.ScanFields "rcd"]])
	if err != nil {
	    err = db.RowFirst(rcd)
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowNext(%+v, %s)\n", data, ErrorString(err))
    [[end]]
    return &data, err
}

//----------------------------------------------------------------------------
//                             Row Page
//----------------------------------------------------------------------------

// RowPage returns a page of rows where a page size is the 'limit' parameter and
// 'offset' is the offset into the result set ordered by the main index. Both
// 'limit' and 'offset' are relative to 1. We return an address to the array
// rows (structs) so that we don't have the overhead of copying them everwhere.
func (db [[.Table.TitledName]]DB) RowPage(offset int, limit int) ([][[.Table.TitledName]], error) {
    var err         error
    var sqlStmt = "[[GenRowPageStmt .Table]]"
    data := [][[.Table.TitledName]]{}

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].RowPage(%d,%d)\n",offset,limit)
    [[end]]

    rows, err := db.dbSql.Query(sqlStmt, limit, offset)
	if err != nil {
	    return data, err
	}

	for rows.Next() {
		var rcd     [[.Table.TitledName]]
		if err = rows.Scan([[.Table.ScanFields "&rcd"]]); err != nil {
			log.Fatal(err)
		} else {
		    data = append(data, rcd)
		}
	}

	rows.Close()

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowPage(%s)\n", ErrorString(err))
    [[end]]
    return data, err
}

//----------------------------------------------------------------------------
//                             Row Prev
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowPrev(rcd *[[.Table.TitledName]]) error {
    var err         error
    var sqlStmt = "[[GenRowPrevStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].RowPrev(%+v)\n", rcd)
    [[end]]

    row := db.dbSql.QueryRow(sqlStmt, rcd)

	err = row.Scan([[.Table.ScanFields "&rcd"]])
	if err != nil {
	    var datap   *[[.Table.TitledName]]
	    err = db.RowLast(rcd)
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowPrev(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Row Update
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) RowUpdate(d *[[.Table.TitledName]]) error {
    var err     error
    var sqlStmt = "[[GenRowInsertStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].RowUpdate(%+v)\n", d)
    [[end]]

    // Validate the input record.

    // Add it to the table.
    _, err = db.dbSql.Exec(sqlStmt, [[.Table.ScanFields "d"]])
	if err != nil {
    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowUpdate(Error:500) - Internal Error\n")
    [[end]]
		err = errors.New("500. Internal Server Error." + err.Error())
	}

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].RowUpdate(%s)\n", ErrorString(err))
    [[end]]
	return err
}


//----------------------------------------------------------------------------
//                             Table Count
//----------------------------------------------------------------------------

func (db [[.Table.TitledName]]DB) TableCount( ) (int, error) {
    var err         error
    var count       int
    var sqlStmt = "[[GenTableCountStmt .Table]]"

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].TableCount()\n")
    [[end]]

    row, err := db.dbSql.Query(sqlStmt)
    if err != nil {
        return 0, err
    }

	err = row.Scan(&count)
    if err != nil {
        return 0, err
    }

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].TableCount(%s) %d\n", ErrorString(err), count)
    [[end]]
    return count, err
}

//----------------------------------------------------------------------------
//                             Table Create
//----------------------------------------------------------------------------

// TableCreate creates the table in the given database deleting the current
// table if present.
func (db [[.Table.TitledName]]DB) TableCreate() error {
    var sqlStmt = "[[GenTableCreateStmt .Table]]"
    var err     error

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].TableCreate()\n")
        log.Printf("\tSQL:\n%s\n", sqlStmt)
    [[end]]

    err = [[.Table.TitledName]]TableDelete()
    if err != nil {
        [[if GenDebugging]]
            log.Printf("...end [[.Table.TitledName]].TableCreate(Error:%s)\n", err.Error())
        [[end]]
        return err
    }
    _, err = db.dbSql.Exec(sqlStmt)

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].TableCreate(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                             Table Delete
//----------------------------------------------------------------------------

// TableDelete deletes the table in the given database if present.
func (db [[.Table.TitledName]]DB) TableDelete() error {
    var sqlStmt = "[[GenTableDeleteStmt .Table]]"
    var err     error

    [[if GenDebugging]]
        log.Printf("[[.Table.TitledName]].TableDelete()\n")
        log.Printf("\tSQL:\n%s\n", sqlStmt)
    [[end]]

    _, err = db.dbSql.Exec(sqlStmt)

    [[if GenDebugging]]
        log.Printf("...end [[.Table.TitledName]].TableDelete(%s)\n", ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                                  New
//----------------------------------------------------------------------------

// NewDB creates a new DB struct.
func [[.Table.TitledName]]NewDB(dbSql *sql.DB) *[[.Table.TitledName]]DB {
    db := [[.Table.TitledName]]DB{}
    db.dbSql = dbSql
    return &db
}

