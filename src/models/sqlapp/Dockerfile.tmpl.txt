[[- $dot := . ]]
[[- $d   := .TD.Data ]]
[[- $dn  := .TD.Data.TitledName ]]
[[- $m   := .TD.Main ]]
[[- $plg := $d.Plugin.Plugin ]]
[[- $typ := $plg.Name ]]
# Generate a minimal Docker container with [[$d.Name]] installed
# vi:nu:et:sts=4 ts=4 sw=4

# Build the application program.
FROM golang:1.12-stretch AS golang
LABEL maintainer="bob@2kranki.us"
ENV GOLANG_DOCKER_CONTAINER=1
[[ if eq $typ "sqlite" -]]
ENV CGO_ENABLED=1
RUN apt-get update && apt-get install --yes sqlite3 libsqlite3-dev
[[- else ]]
ENV CGO_ENABLED=0
[[- end ]]
ENV GOOS=linux
RUN go get github.com/2kranki/jsonpreprocess \
    && go get github.com/2kranki/go_util \
    && go get github.com/shopspring/decimal \
    && go get [[$plg.GenImportString]]
WORKDIR /go/src
COPY ./src/* ./
RUN go build -o /go/bin/[[$d.Name]] .                                       

# We put the application program built in the prior step into
# /usr/local/app including all of its support files.
FROM ubuntu:cosmic AS production
# Note: we must keep glibc version the same as in the golang container.
LABEL maintainer="bob@2kranki.us"
[[ if eq $typ "sqlite" -]]
RUN apt-get update && apt-get upgrade --yes && apt-get install --yes sqlite3 libsqlite3-dev
[[- else ]]
RUN apt-get update && apt-get upgrade --yes
[[- end ]]
WORKDIR /usr/local/app
COPY --from=golang /go/bin/[[$d.Name]] .
# Warning: COPY does not copy the actual directory, just its contents.
#           So, we must create those directories first, then COPY.
WORKDIR /usr/local/app/css
COPY ./css      .
WORKDIR /usr/local/app/html
COPY ./html     .
WORKDIR /usr/local/app/static
COPY ./static   .
WORKDIR /usr/local/app/tmpl
COPY ./tmpl     .
WORKDIR /usr/local/app
# The web server ip/port are different when running in the container
# vs batch.
ENV [[$d.UpperName]]_HTTP_SERVER="0.0.0.0"
ENV [[$d.UpperName]]_HTTP_PORT="[[$m.Port]]"
EXPOSE [[$m.Port]]

CMD ["/usr/local/app/[[$d.Name]]"]

