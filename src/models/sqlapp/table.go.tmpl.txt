// vi:nu:et:sts=4 ts=4 sw=4
// See License.txt in main repository directory

//  Struct and Methods for [[.TD.Data.TitledName]][[.Table.TitledName]]

// Generated: [[Time]]
[[- $dot := .]]
[[- $d  := .TD.Data]]
[[- $dn := .TD.Data.TitledName]]
[[- $t  := .Table]]
[[- $tn := .Table.TitledName]]


package [[$dn]][[$tn]]

import (
    "fmt"
    [[if GenDebugging]]
        "log"
    [[end]]
	"net/http"
	"strconv"
	"strings"
     [[if $d.HasDate]]
        "time"
    [[end]]
	"net/url"
)

//============================================================================
//                              Miscellaneous
//============================================================================

[[if GenDebugging]]
func ErrorString(err error) string {
    if err == nil {
        return "ok"
    } else {
        return err.Error()
    }
}
[[end]]

//============================================================================
//                             Database Interfaces
//============================================================================

type DbRowDeleter interface {
    // RowDelete deletes the row with keys from the provided record, rcd.
    RowDelete(rcd *[[$tn]]) error
}

type DbRowFinder interface {
    // RowFind searches the Database for a matching row for the keys found in
    // the given record and returns the output in that same record.
    RowFind(rcd *[[$tn]]) error
}

type DbRowFirster interface {
    // RowFirst returns the first row in the table, [[$tn]].
    // If there are no rows in the table, then a blank/null record is returned
    // without error.
    RowFirst(rcd *[[$tn]]) error
}

type DbRowInserter interface {
    RowInsert(rcd *[[$tn]]) error
}

type DbRowLaster interface {
    // RowLast returns the last row in the table, [[$tn]].
    // If there are no rows in the table, then a blank/null record is returned
    // without error.
    RowLast(rcd *[[$tn]]) error
}

type DbRowNexter interface {
    // RowNext returns the next row from the row given. If row after the current
    // one does not exist, then the first row is returned.
    RowNext(rcd *[[$tn]]) error
}

type DbRowPager interface {
    // RowPage returns a page of rows where a page size is the 'limit' parameter and
    // 'offset' is the offset into the result set ordered by the main index. Both
    // 'limit' and 'offset' are relative to 1. We return an address to the array
    // rows (structs) so that we don't have the overhead of copying them everwhere.
    RowPage(offset int, limit int) ([][[$tn]], error)
}

type DbRowPrever interface {
    RowPrev(rcd *[[$tn]]) error
}

type DbRowUpdater interface {
    RowUpdate(rcd *[[$tn]]) error
}

type DbTableCounter interface {
    TableCount() (int, error)
}

type DbTableCreater interface {
    TableCreate() error
}

type DbTableDeleter interface {
    TableDelete() error
}

//============================================================================
//                              Table Struct
//============================================================================

[[$t.CreateStruct]]

//----------------------------------------------------------------------------
//                              Compare
//----------------------------------------------------------------------------

// Compare compares our struct to another returning
// 0, 1 for equal and not equal.
func (s *[[$tn]]) Compare(r *[[$tn]]) int {
    // Accumulate the key value(s) in KeyNum order.
    [[range $f := $t.Fields -]]
        if s.[[$f.TitledName]] != r.[[$f.TitledName]] {
            return 1
        }
	[[end -]]

	return 0
}

// CompareKeys compares our struct to another using keys returning the normal
// -1, 0, 1 for less than, equal and greater than.
func (s *[[$tn]]) CompareKeys(r *[[$tn]]) int {
    // Accumulate the key value(s) in KeyNum order.
    [[range $fn := $t.Keys -]]
        [[ $f := $t.FindField $fn -]]
            // Field: [[$f.TitledName]]
            if s.[[$f.TitledName]] != r.[[$f.TitledName]] {
                if s.[[$f.TitledName]] < r.[[$f.TitledName]] {
                    return -1
                } else {
                    return 1
                }
            }
	[[end -]]

	return 0
}

//----------------------------------------------------------------------------
//                             Empty
//----------------------------------------------------------------------------

// Empty resets the struct values to their null values.
func (s *[[$tn]]) Empty() {
[[if $t.HasDate -]]
    var date    time.Time
[[end -]]
[[if $t.HasInteger -]]
    var i64     int64
[[end -]]
[[if $t.HasFloat -]]
    var f64     float64
[[end -]]
[[if $t.HasText -]]
    var str     string
[[end]]

[[range $f := $t.Fields -]]
    [[if $f.IsText -]]
        s.[[$f.TitledName]] = str
    [[else if $f.IsDate -]]
        s.[[$f.TitledName]] = date
    [[else if $f.IsInteger -]]
        s.[[$f.TitledName]] = i64
    [[else if $f.IsFloat -]]
        s.[[$f.TitledName]] = f64
    [[end -]]
[[end]]
}

//----------------------------------------------------------------------------
//                      Fields to URL Value String
//----------------------------------------------------------------------------

// FieldsToValue creates a URL Value map from the the table's field(s).
func (s *[[$tn]]) FieldsToValue() string {
    var wrk string

    v := url.Values{}
    // Accumulate the value(s) from the fields.
    [[range $f := $t.Fields -]]
            // Field: [[$f.TitledName]]
            [[$f.GenToString "wrk" "s" -]]
            v.Add("[[$f.TitledName]]", wrk)
	[[end -]]

	return v.Encode()
}

//----------------------------------------------------------------------------
//                      Keys to URL Value String
//----------------------------------------------------------------------------

// KeysToValue creates a URL Value map from the table's key(s).
func (s *[[$tn]]) KeysToValue() string {
    var wrk string
    var i   int

    i = 0
    v := url.Values{}
    // Accumulate the key value(s) in KeyNum order.
    [[range $fn := $t.Keys -]]
        [[ $f := $t.FindField $fn -]]
            // Field: [[$f.TitledName]]
            [[$f.GenToString "wrk" "s" -]]
            v.Add(fmt.Sprintf("key%d", i), wrk)
            i++
	[[end -]]

	return v.Encode()
}

//----------------------------------------------------------------------------
//                             List Output
//----------------------------------------------------------------------------

func (s *[[$tn]]) ListOutput() string {
	var str strings.Builder
    var wrk string

    if s == nil {
        return ""
    }

    [[range $f := $t.Fields -]]
        [[if $f.List -]]
            // Field: [[$f.TitledName]]
            str.WriteString("<td>")
            [[if $f.KeyNum -]]
                wrk = fmt.Sprintf("<a href=\"/[[$tn]]/find?%s\">", s.KeysToValue())
                str.WriteString(wrk)
            [[end -]]
            [[$f.GenToString "wrk" "s" -]]
            str.WriteString(wrk)
            //str.WriteString("\n")
            [[if $f.KeyNum -]]
                str.WriteString("</a>" )
            [[end -]]
            str.WriteString("</td>\n")
        [[end -]]
	[[end -]]

	return str.String()
}

//----------------------------------------------------------------------------
//                  Request Form Value(s) to Struct
//----------------------------------------------------------------------------

// [[.Table.TitledName]]Request2Struct converts the form values to a struct. FormValue(s) are available
// for both, GET and POST.  It is just that all your parameters are present in the URL if you use
// GET.  In general, you should use POST with this function for security reasons.
func (s *[[$tn]]) Request2Struct(r *http.Request) error {
    var err         error
    var str         string

    [[if GenDebugging]]
        log.Printf("[[$tn]].Request2Struct()\n")
        log.Printf("\tr.FormValue: %q\n", r.Form)
    [[end]]

    s.Empty()
    [[range $f := .Table.Fields -]]
        str = r.FormValue("[[$f.TitledName]]")
        [[$f.GenFromString "s" "str" -]]
    [[end]]

    [[if GenDebugging]]
        log.Printf("...end [[$tn]]Request2Struct(%+v, %s)\n", s, ErrorString(err))
    [[end]]
    return err
}

//----------------------------------------------------------------------------
//                      Set Keys from a Slice of Strings
//----------------------------------------------------------------------------

// SetKeysFromStrings creates a URL Value map from the table's key(s). The slice
// is in field order within the struct, not sorted by field name.
func (s *[[$tn]]) SetKeysFromStrings(strs []string) error {
    var i   int

    if len(strs) != [[$t.KeyCount]] {
        return fmt.Errorf("Error - Invalid key count of %d, need %d!\n", len(strs), [[$t.KeyCount]])
    }
    // Accumulate the key value(s) in KeyNum order.
    [[range $fn := $t.Keys -]]
        [[ $f := $t.FindField $fn -]]
            [[$f.GenFromString "s" "strs[i]" -]]
            i++
	[[end -]]

	return nil
}

//----------------------------------------------------------------------------
//                             Test Data
//----------------------------------------------------------------------------

// TestData takes the given integer and uses it to fill most of the fields in
// with data derived from it. 'i' is relative to zero.
func (s *[[$tn]]) TestData(i int) {
    var chr     rune
[[if $t.HasDate -]]
    var date    time.Time
[[end -]]
[[if $t.HasInteger -]]
    var i64     int64
[[end -]]
[[if $t.HasFloat -]]
    var f64     float64
[[end -]]
[[if $t.HasText -]]
    var str     string
[[end]]
    if i < 27 {
        chr = rune(65 + i)      // A
    } else if i < 55 {
        chr = rune(97 + i)      // a
    } else {
        chr = rune(65)          // A
    }
[[if $t.HasInteger ]]
    i64 = int64(i)
[[end -]]
[[if $t.HasFloat -]]
    f64 = float64(i)
[[end -]]
[[if $t.HasText -]]
    str = string(chr)
[[end]]

    [[range $f := $t.Fields -]]
        [[if $f.IsText -]]
            s.[[$f.TitledName]] = str
        [[else if $f.IsDate -]]
            s.[[$f.TitledName]] = date
        [[else if $f.IsInteger -]]
            s.[[$f.TitledName]] = i64
            [[if $f.Incr -]]
                s.[[$f.TitledName]]++       // auto-increment fields are relative to one not zero
            [[end -]]
        [[else if $f.IsFloat -]]
            s.[[$f.TitledName]] = f64
        [[end -]]
	[[end]]
}

//----------------------------------------------------------------------------
//                             New Struct
//----------------------------------------------------------------------------

// [[$tn]]New creates a new empty struct.
func [[$tn]]New() *[[$tn]] {
    return &[[$tn]]{}
}


